<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure Vault - Stateless Key Mode</title>
    <style>
        /* COLOR PALETTE */
        :root {
            --primary-blue: #1A73E8; 
            --primary-dark: #174EA6;
            --success-green: #34A853;
            --error-red: #EA4335;
            --background-light: #F8F9FA;
            --surface-white: #FFFFFF;
            --text-dark: #202124;
            --text-medium: #5F6368;
        }

        /* BASE STYLES & TYPOGRAPHY */
        body {
            font-family: Roboto, Arial, sans-serif;
            background-color: var(--background-light);
            display: flex;
            justify-content: center;
            align-items: flex-start; 
            min-height: 100vh;
            padding-top: 50px;
            margin: 0;
        }
        .container {
            background-color: var(--surface-white);
            padding: 30px;
            border-radius: 8px; 
            box-shadow: 0 1px 3px 0 rgba(60, 64, 67, 0.302), 0 4px 8px 3px rgba(60, 64, 67, 0.149); 
            width: 750px; 
            max-width: 95%;
        }
        h2 {
            text-align: center;
            margin-bottom: 25px;
            color: var(--text-dark);
            font-weight: 500; 
        }
        h3, h4 {
            color: var(--text-dark);
            border-bottom: 1px solid #E8EAED;
            padding-bottom: 8px;
            margin-bottom: 15px;
            font-weight: 500;
        }
        .form-group {
            margin-bottom: 24px;
        }
        label {
            display: block;
            margin-bottom: 4px;
            font-weight: 500;
            color: var(--text-medium);
            font-size: 0.9em;
        }
        
        /* INPUT STYLING */
        input:not([type="checkbox"]), textarea {
            width: 100%;
            padding: 12px 12px;
            border: 1px solid #DADCE0; 
            border-radius: 4px; 
            box-sizing: border-box;
            transition: border-color 0.2s, box-shadow 0.2s;
            font-size: 1em;
            color: var(--text-dark);
        }
        input:focus, textarea:focus {
            border-color: var(--primary-blue);
            box-shadow: 0 0 0 1px var(--primary-blue);
            outline: none;
        }
        textarea {
            min-height: 100px;
            resize: vertical; 
        }

        /* UTILITY BUTTONS */
        .utility-button, button.copy-utility-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px; 
            font-size: 1.2em; 
            line-height: 1; 
            color: var(--text-medium);
            transition: color 0.2s;
        }
        .utility-button:hover, button.copy-utility-button:hover {
            color: var(--primary-blue);
        }
        .input-utility-group {
            display: flex;
            align-items: center;
            border: 1px solid #DADCE0;
            border-radius: 4px;
            padding-right: 0; 
            background-color: var(--surface-white);
        }
        .input-utility-group:focus-within {
             border: 1px solid var(--primary-blue);
             box-shadow: 0 0 0 1px var(--primary-blue);
        }
        .input-utility-group input, .input-utility-group textarea {
            border: none;
            padding: 12px;
            box-shadow: none;
        }
        .input-utility-group .utility-button {
             padding: 0 12px;
        }
        
        /* PRIMARY ACTION BUTTONS */
        button[type="submit"], 
        .list-utility-row button, 
        .password-group button:not(.utility-button),
        .save-button {
            padding: 10px 20px;
            color: var(--surface-white);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            margin-left: 8px;
            transition: background-color 0.2s, box-shadow 0.2s;
            box-shadow: 0 1px 2px 0 rgba(60,64,67,.3), 0 1px 3px 1px rgba(60,64,67,.15); 
        }
        
        button[type="submit"] {
            width: 100%;
            background-color: var(--primary-blue);
            margin-top: 20px; 
            margin-left: 0;
        }
        button[type="submit"]:hover {
            background-color: var(--primary-dark);
            box-shadow: 0 2px 3px 0 rgba(60,64,67,.3), 0 2px 6px 2px rgba(60,64,67,.15);
        }
        
        /* GENERATE BUTTONS */
        .password-group button:not(.utility-button) {
            background-color: #3C4043; 
        }
        .password-group button:not(.utility-button):hover {
            background-color: #5F6368;
        }

        /* SAVE BUTTON */
        .save-button {
            background-color: var(--success-green); 
            margin-left: 0; 
            margin-top: 10px; 
            width: 100%;
        }
        .save-button:hover {
            background-color: #2F8745; 
        }
        .button-group-row {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        /* MENU SWITCH BUTTONS */
        .menu-switch, .mode-switch {
            display: flex;
            justify-content: space-around;
            margin-bottom: 25px;
            border-bottom: 2px solid #E8EAED;
        }
        .menu-switch button, .mode-switch button {
            flex: 1;
            padding: 12px 10px;
            border: none;
            background-color: transparent;
            color: var(--text-medium);
            cursor: pointer;
            transition: color 0.2s;
            font-weight: 500;
            position: relative;
        }
        .menu-switch button.active, .mode-switch button.active {
            color: var(--primary-blue);
            font-weight: 600;
        }
        /* Active Tab Underline */
        .menu-switch button.active::after, .mode-switch button.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 100%;
            height: 2px;
            background-color: var(--primary-blue);
        }

        /* STATUS & ERROR MESSAGES */
        #status_message {
            text-align: center;
            padding: 12px;
            margin-bottom: 20px;
            border-radius: 4px;
            display: none;
            font-weight: 500;
            transition: opacity 0.3s ease;
        }
        .status-success {
            background-color: #E6F4EA; 
            color: var(--success-green);
        }
        .status-error, .error-message {
            background-color: #FCE8E6; 
            color: var(--error-red);
        }
        .error-message {
            padding: 8px;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 0.9em;
            display: none;
            background-color: transparent;
            border: none;
            color: var(--error-red); 
        }

        /* LISTING STYLES */
        #secret_list_content {
            margin-top: 15px;
            padding: 0;
            max-height: 400px;
            overflow-y: auto;
            background-color: var(--surface-white);
        }
        #secret_list_content h4 {
            border-bottom: none;
            margin-top: 15px;
            padding: 5px 15px 5px 0;
            font-size: 1em;
            color: var(--primary-blue); 
            font-weight: 600;
        }
        #secret_list_content ul {
            list-style: none;
            padding: 0;
            margin-bottom: 20px;
        }
        .secret-item {
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #F1F3F4;
            transition: background-color 0.2s;
        }
        .secret-item:hover {
            background-color: #F8F9FA;
        }
        .secret-item:last-child {
            border-bottom: none;
        }
        .secret-item-info {
            padding-left: 15px;
        }
        .secret-item-info strong {
            color: var(--text-dark);
            font-size: 1em;
        }
        .secret-item-info span {
            font-size: 0.85em;
            color: var(--text-medium);
            margin-left: 10px;
            font-style: italic;
        }
        .inline-decrypt-button {
            padding: 8px 15px;
            background-color: var(--success-green); 
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            margin-right: 15px;
            box-shadow: 0 1px 2px 0 rgba(60,64,67,.3), 0 1px 3px 1px rgba(60,64,67,.15);
        }
        .inline-decrypt-button:hover {
            background-color: #2F8745;
        }
        .list-utility-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            gap: 10px;
            padding: 0 15px;
        }
        #search_input {
            flex-grow: 1;
            padding: 10px;
            border-radius: 20px; 
            border: 1px solid #DADCE0;
            background-color: #F1F3F4;
        }

        /* DECRYPTION DETAILS VIEW */
        #secret_details {
            margin-top: 25px;
            border-top: 1px solid #E8EAED; 
            padding-top: 20px;
            padding-left: 15px;
            padding-right: 15px;
        }
        .details-viewer-header {
             display: flex; 
             justify-content: space-between; 
             align-items: center;
             margin-bottom: 15px;
        }
        .details-viewer-header h4 {
             border-bottom: none;
             margin-bottom: 0;
             font-weight: 600;
             color: var(--primary-blue);
        }
        .details-viewer-header button {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            margin-left: 10px;
            font-weight: 500;
        }
        .details-viewer-header button.edit-button {
            background-color: var(--primary-blue); 
            color: white;
        }
        .details-viewer-header button.edit-button:hover {
            background-color: var(--primary-dark);
        }
        .details-viewer-header button.delete-button {
            background-color: var(--error-red); 
            color: white;
        }
        .details-viewer-header button.delete-button:hover {
            background-color: #CC0000;
        }
        .details-viewer-header #close_details_button {
            background-color: #F1F3F4;
            color: var(--text-dark);
            box-shadow: none;
        }
        .details-viewer-header #close_details_button:hover {
            background-color: #E8EAED;
        }

        /* Decryption Output Styling */
        #decryption_output pre, #decryption_output div.content-box {
            background: #f8f9fa; 
            padding: 15px; 
            border-radius: 8px;
            border: 1px solid #E8EAED;
        }
        .decrypted-field {
            margin-bottom: 10px;
            padding: 8px 0;
            border-bottom: 1px dotted #DADCE0;
            display: flex; 
            align-items: center;
            justify-content: space-between; 
        }
        .field-label {
            font-weight: 600;
            color: var(--text-dark);
        }
        
        button.copy-utility-button {
            background: #E8EAED;
            border: none;
            padding: 5px 10px;
            font-size: 0.8em;
            border-radius: 4px;
            margin-left: 10px;
            color: var(--text-dark);
        }
        button.copy-utility-button:hover {
            background: #DADCE0;
        }
        
        /* Strength Meter */
        #password_meter {
            height: 4px; 
            border-radius: 2px;
            margin-top: 5px;
            background: #E8EAED;
            overflow: hidden;
        }
        .weak { background-color: var(--error-red); }
        .medium { background-color: #FBBC04; } 
        .strong { background-color: var(--success-green); }
        
        .password-group {
             display: flex;
             align-items: center;
             gap: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Secure Vault (Stateless Key Mode)</h2>
        
        <div id="status_message"></div>

        <div class="menu-switch">
            <button type="button" id="btn_entry" class="active" onclick="switchMenu('entry')">‚ú® New Entry</button>
            <button type="button" id="btn_list" onclick="switchMenu('list')">üìÑ Stored Secrets</button>
        </div>

        <div class="form-group" id="global_keys">
            <label for="master_password">üîê Master Password:</label>
            <div class="input-utility-group">
                <input type="password" id="master_password" name="master_password" placeholder="Enter your master key (required for encrypt/decrypt)"> 
                <button type="button" class="utility-button" onclick="togglePasswordVisibility('master_password')" title="Show Entry Decryption Master Password">üëÅÔ∏è</button>
            </div>

            <label for="github_token_input" style="margin-top: 15px;">üë§ GitHub Personal Access Token (PAT):</label>
            <div class="input-utility-group">
                <input type="password" id="github_token_input" name="github_token_input" placeholder="Token from config.json (or enter a temporary one)"> 
                <button type="button" class="utility-button" onclick="togglePasswordVisibility('github_token_input')" title="Show Token">üëÅÔ∏è</button>
            </div>
            
            <div class="button-group-row">
                 <button type="button" class="save-button" onclick="saveCredentials()">üíæ Save Token Locally (Recommended)</button>
                 <button type="button" class="save-button" onclick="deleteCredentials()" style="background-color: var(--error-red);">üóëÔ∏è Clear All Saved Credentials</button>
            </div>

            <p id="key_status_hint" style="margin-top: 10px; font-size: 0.85em; display: block; color: var(--success-green);">
                ‚úÖ **Security Best Practice:** Only the **GitHub Token** is automatically loaded from local storage. **Always re-enter your Master Password** for maximum security.
            </p>
        </div>
        
        <hr style="border: 0; border-top: 1px solid #E8EAED; margin: 30px 0;">

        <div id="form_view">
            <h3>New Secure Entry</h3>
            <div class="mode-switch">
                <button type="button" id="btn_website" class="active" onclick="switchMode('website')">üåê Login/Website</button>
                <button type="button" id="btn_text" onclick="switchMode('text')">üìù Secure Note</button>
            </div>

            <form action="#" method="post" onsubmit="return validatePassword(event)">
                <div id="website_fields" class="form-mode-group">
                    <div class="form-group">
                        <label for="website">Website URL:</label>
                        <input type="text" id="website" name="website" placeholder="e.g., example.com" required>
                    </div>
                    <div class="form-group">
                        <label for="username">Username/Email (Login):</label>
                        <div class="input-utility-group">
                            <input type="text" id="username" name="username" placeholder="Enter your username or email" required>
                            <button type="button" class="utility-button" onclick="copyToClipboard('username')" title="Copy Username">üìã</button>
                        </div>
                    </div>
                </div>

                <div id="text_fields" class="form-mode-group" style="display: none;">
                     <div class="form-group">
                        <label for="name">Name/Title:</label>
                        <input type="text" id="name" name="name" placeholder="e.g., Secure Note Title" required disabled>
                    </div>
                    <div class="form-group">
                        <label for="content">Content/Note:</label>
                        <div class="input-utility-group">
                            <textarea id="content" name="content" placeholder="Enter your secret text or note" required disabled></textarea>
                            <button type="button" class="utility-button" onclick="copyToClipboard('content')" title="Copy Note Content">üìã</button>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label for="password">Stored Password:</label>
                    <div class="password-group">
                        <div class="input-utility-group" style="flex-grow: 1;">
                            <input type="password" id="password" name="password" placeholder="Enter or generate a password" onkeyup="checkPasswordStrength()" required>
                            <button type="button" class="utility-button" onclick="togglePasswordVisibility('password')" title="Show Password">üëÅÔ∏è</button>
                            <button type="button" class="utility-button" onclick="copyToClipboard('password')" title="Copy Password">üìã</button>
                        </div>
                        <button type="button" onclick="generatePassphrase()" title="Generate random passphrase">Words</button> 
                        <button type="button" onclick="generatePassword()" title="Generate random mixed-character password">Gen</button>
                    </div>
                    
                    <div id="password_meter">
                        <div id="password_bar"></div>
                    </div>
                    <div id="strength_display" class="strength-text"></div>
                </div>

                <div class="form-group">
                    <label for="confirm_password">Confirm Stored Password:</label>
                    <div class="input-utility-group">
                        <input type="password" id="confirm_password" name="confirm_password" placeholder="Re-enter your password" required>
                        <button type="button" class="utility-button" onclick="togglePasswordVisibility('confirm_password')" title="Show Confirmation Password">üëÅÔ∏è</button>
                    </div>
                    <p id="password_error" class="error-message">Passwords do not match!</p>
                </div>

                <button type="submit">üîí Encrypt & Send</button>
            </form>
        </div>

        <div id="list_view" style="display: none;">
            <h3>Stored Secrets List (GitHub)</h3>
            
            <div class="list-utility-row">
                <input type="text" id="search_input" placeholder="Filter secrets by name..." onkeyup="filterSecretList()">
                <button type="button" onclick="refreshSecretList()">üîÑ Refresh</button>
            </div>

            <div id="secret_list_content">
                <p style="padding-left: 15px;">Click "Refresh" to load secrets from your GitHub repository.</p>
            </div>
            
            <div id="secret_details" style="display: none;">
                <div class="details-viewer-header">
                    <h4>Decrypted Details for: <span id="selected_secret_name"></span></h4>
                    <div>
                        <button id="delete_button" class="delete-button" style="display:none;" title="Permanently archive this entry" onclick="deleteSecret()">üóëÔ∏è Archive</button>
                        <button id="edit_button" class="edit-button" style="display:none;" title="Edit/Re-encrypt this entry">‚úèÔ∏è Edit</button>
                        <button id="close_details_button" onclick="document.getElementById('secret_details').style.display='none'">Close</button>
                    </div>
                </div>
                <div id="decryption_output" style="margin-top: 10px;">
                    <p>Select a secret and click **Decrypt** to view its contents.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration Object ---
        let config = null;
        const DIC = ["apple", "river", "cloud", "snake", "ocean", "pizza", "happy", "zebra", "music", "light", "house", "chair", "table", "phone", "plant", "green", "tiger", "earth", "dream", "robot", "magic", "ghost", "knife", "spoon", "sugar", "heart", "moon", "star", "jelly", "socks"];
        
        // --- GLOBAL STATE FOR CURRENTLY DECRYPTED SECRET ---
        window.currentSecretPath = null; 

        // --- Configuration Loader ---
        async function loadConfig() {
            try {
                const response = await fetch('config.json');
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                config = await response.json();
                
                // === LOGIC FOR FILLING TOKEN FROM CONFIG (IF NO LOCAL SAVE) ===
                const tokenInput = document.getElementById('github_token_input');
                const ghConfig = config.github_config;

                if (ghConfig && ghConfig.token && ghConfig.token !== 'YOUR_PERSONAL_ACCESS_TOKEN') {
                    tokenInput.value = ghConfig.token;
                    tokenInput.placeholder = 'Token loaded from config.json'; 
                    setStatus("GitHub Token loaded automatically from config.json.", false);
                } else {
                    tokenInput.placeholder = 'Token from config.json (or enter a temporary one)'; 
                }
                // === END LOGIC ===

            } catch (error) {
                console.error("Failed to load config.json:", error);
                setStatus("FATAL ERROR: Could not load config.json. Check file path and network.", true);
                throw error; 
            }
        }
        
        // --- Global Status Message Helper ---
        function setStatus(message, isError = false) {
            const statusDiv = document.getElementById('status_message');
            statusDiv.textContent = message;
            statusDiv.className = isError ? 'status-error' : 'status-success';
            statusDiv.style.display = 'block';
            setTimeout(() => { statusDiv.style.display = 'none'; }, 8000);
        }

        // --- IndexedDB for Credential Storage ---
        const DB_NAME = 'SecureVaultCreds';
        const STORE_NAME = 'credentials';
        const CRED_KEY = 'saved_auth';

        function openCredsDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, 1);
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME);
                    }
                };

                request.onsuccess = (event) => {
                    resolve(event.target.result);
                };

                request.onerror = (event) => {
                    reject(new Error(`IndexedDB error: ${event.target.errorCode}`));
                };
            });
        }

        // NOTE: We only save the GitHub token and an empty/null Master Password
        async function saveCreds(masterPassword, githubToken) {
            try {
                const db = await openCredsDB();
                const tx = db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                
                const data = { 
                    masterPassword: masterPassword, // This will be saved, but recommended to be blank
                    githubToken: githubToken,
                    savedAt: new Date().toISOString()
                };
                
                return new Promise((resolve, reject) => {
                    const request = store.put(data, CRED_KEY);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(new Error('Failed to save credentials.'));
                });
                
            } catch (error) {
                console.error("Save Creds Error:", error);
                throw error;
            }
        }

        async function getCreds() {
             try {
                const db = await openCredsDB();
                const tx = db.transaction(STORE_NAME, 'readonly');
                const store = tx.objectStore(STORE_NAME);
                
                return new Promise((resolve, reject) => {
                    const request = store.get(CRED_KEY);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(new Error('Failed to retrieve credentials.'));
                });
                
            } catch (error) {
                return null;
            }
        }

        async function deleteCreds() {
            try {
                const db = await openCredsDB();
                const tx = db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);
                
                return new Promise((resolve, reject) => {
                    const request = store.delete(CRED_KEY);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(new Error('Failed to delete credentials.'));
                });
                
            } catch (error) {
                 console.error("Delete Creds Error:", error);
                 throw error;
            }
        }
        
        async function loadStoredCredentials() {
            const creds = await getCreds();
            const tokenInput = document.getElementById('github_token_input');
            const masterPasswordInput = document.getElementById('master_password');
            
            if (creds && creds.githubToken) {
                 // 1. ALWAYS load the GitHub token if it exists
                 tokenInput.value = creds.githubToken;
                 
                 // 2. DO NOT load the Master Password, even if it's saved.
                 // This enforces the security best practice of re-entering the key.
                 masterPasswordInput.value = ''; 
                 
                 setStatus("GitHub Token loaded automatically from local storage. Please re-enter your Master Password.", false);
            } else if (creds) {
                 await deleteCreds();
            }
        }

        // --- UI Callbacks for Credential Management (UPDATED) ---

        async function saveCredentials() {
            let masterPassword = document.getElementById("master_password").value;
            const githubToken = document.getElementById("github_token_input").value;

            if (githubToken.length === 0 || githubToken === 'YOUR_PERSONAL_ACCESS_TOKEN') {
                 setStatus("GitHub Token must be entered to save.", true);
                 return;
            }

            // Security check and advisory
            if (masterPassword.length > 0) {
                 const confirmSaveMP = confirm("SECURITY WARNING: It is strongly recommended to NOT save your Master Password in the browser. Do you wish to clear the Master Password field but save the GitHub Token?");
                 if (confirmSaveMP) {
                      masterPassword = ''; // Set to blank for saving
                 } else {
                      // If user insists on saving, proceed, but still advise
                      setStatus("WARNING: Master Password saved. It is highly recommended to clear it from local storage after use.", true);
                 }
            }

            try {
                 await saveCreds(masterPassword, githubToken);
                 
                 // Clear the field after saving/advising
                 document.getElementById('master_password').value = ''; 
                 
                 setStatus("‚úÖ GitHub Token saved securely. Master Password field cleared (as advised).", false);
            } catch (error) {
                 setStatus(`Error saving credentials: ${error.message}`, true);
            }
        }
        
        async function deleteCredentials() {
            const confirmDelete = confirm("Are you sure you want to permanently clear the saved credentials (Token and Password) from your browser?");
            if (!confirmDelete) return;

            try {
                 await deleteCreds();
                 document.getElementById('master_password').value = '';
                 document.getElementById('github_token_input').value = '';
                 setStatus("üóëÔ∏è Saved credentials have been cleared from local browser storage.", false);
            } catch (error) {
                 setStatus(`Error deleting credentials: ${error.message}`, true);
            }
        }

        // --- Cryptography Functions (NO REDUNDANT HMAC) ---

        /**
         * Stateless key derivation: derives ONLY the Cipher Key using Master Password and a unique per-entry salt.
         * @param {string} masterPassword - The user's master key.
         * @param {Uint8Array} salt - A unique salt for the entry (must be stored with the entry data).
         * @returns {Promise<{cipherKey: CryptoKey}>}
         */
        async function deriveKeys(masterPassword, salt) {
            const C = config.crypto_config;
            
            const masterKey = await window.crypto.subtle.importKey(
                "raw", new TextEncoder().encode(masterPassword), { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]
            );
            
            // Derive only 256 bits (32 bytes) for the single AES-256-GCM key
            const derivedBits = await window.crypto.subtle.deriveBits(
                {
                    name: "PBKDF2",
                    salt: salt, 
                    iterations: C.pbkdf2_iterations,
                    hash: C.pbkdf2_hash_algo,
                },
                masterKey,
                256 // Reduced from 512
            );
            
            const derivedBitsArray = new Uint8Array(derivedBits);
            
            const cipherBits = derivedBitsArray.slice(0, 32); 

            const cipherKey = await window.crypto.subtle.importKey(
                "raw", cipherBits, { name: C.key_algo_name, length: C.key_algo_length }, true, ["encrypt", "decrypt"]
            );
            
            return { cipherKey };
        }
        
        /**
         * Encrypts data using a newly generated salt and returns the package including salt.
         * NOTE: Relies on AES-GCM's built-in tag for integrity; no external HMAC is used.
         * @param {string} masterPassword - The user's master key.
         * @param {string} data - The JSON string data to encrypt.
         * @returns {Promise<{ciphertext: number[], iv: number[], salt: number[]}>}
         */
        async function encryptData(masterPassword, data) {
            const C = config.crypto_config;
            const encodedData = new TextEncoder().encode(data);
            const iv = window.crypto.getRandomValues(new Uint8Array(12)); 
            const salt = window.crypto.getRandomValues(new Uint8Array(16)); 
            
            // 1. Derive cipher key (only one key now)
            const { cipherKey } = await deriveKeys(masterPassword, salt);

            // 2. Encrypt (Output contains the GCM tag appended to the ciphertext)
            const ciphertextWithTag = await window.crypto.subtle.encrypt(
                { name: C.key_algo_name, iv: iv }, 
                cipherKey,
                encodedData
            );
            
            // 3. Return package
            return {
                ciphertext: Array.from(new Uint8Array(ciphertextWithTag)),
                iv: Array.from(iv),
                salt: Array.from(salt) 
                // NOTE: The HMAC 'tag' field is removed.
            };
        }

        /**
         * Decrypts data using derived keys. Relies on AES-GCM's internal tag verification.
         * @param {CryptoKey} cipherKey - The derived cipher key.
         * @param {number[]} iv - Initialization vector.
         * @param {number[]} ciphertext - Encrypted data (including GCM tag).
         * @returns {Promise<string>}
         */
        async function decryptData(cipherKey, iv, ciphertext) {
            const C = config.crypto_config;
            const ciphertextArray = new Uint8Array(ciphertext);
            
            // Decrypt automatically performs GCM tag verification. 
            // If verification fails, it throws an OperationError.
            const decrypted = await window.crypto.subtle.decrypt(
                { name: C.key_algo_name, iv: new Uint8Array(iv) },
                cipherKey,
                ciphertextArray
            );
            
            return new TextDecoder().decode(decrypted);
        }
        
        function getSafeMetadata() {
            const ua = navigator.userAgent;
            let browser = 'Unknown';
            if (ua.indexOf("Chrome") > -1 && ua.indexOf("Edg") === -1) {
                browser = ua.match(/Chrome\/(\S+)/) ? ua.match(/Chrome\/(\S+)/)[0] : 'Chrome (version missing)';
            } else if (ua.indexOf("Firefox") > -1) {
                browser = ua.match(/Firefox\/(\S+)/) ? ua.match(/Firefox\/(\S+)/)[0] : 'Firefox (version missing)';
            } else if (ua.indexOf("Edg") > -1) {
                browser = ua.match(/Edg\/(\S+)/) ? ua.match(/Edg\/(\S+)/)[0] : 'Edge (version missing)';
            } else if (ua.indexOf("Safari") > -1) {
                browser = ua.match(/Version\/(\S+)/) ? ua.match(/Version\/(\S+)/)[0] + " Safari" : 'Safari (version missing)';
            }
            return {
                platform: navigator.platform,
                browser: browser,
                saveTime: new Date().toISOString()
            };
        }


        // --- FORM SUBMISSION LOGIC ---

        function getCurrentTimestampISO() {
            return new Date().toISOString();
        }


        async function validatePassword(event) {
            event.preventDefault(); 
            
            if (!config) { setStatus("Configuration not available. Please refresh.", true); return; }

            const password = document.getElementById("password").value;
            const confirmPassword = document.getElementById("confirm_password").value;
            const masterPassword = document.getElementById("master_password").value;
            const tokenInput = document.getElementById('github_token_input').value.trim();
            const activeMode = document.getElementById('btn_website').classList.contains('active') ? 'website' : 'text';
            
            const ghConfig = config.github_config;

            const token = tokenInput;

            // Final configuration validation before API call
            if (!ghConfig.repository || !ghConfig.workflow_name || !token || token === 'YOUR_PERSONAL_ACCESS_TOKEN') {
                 setStatus("Configuration Error: GitHub repository, workflow_name, or token is missing/default. **Check GitHub Token field.**", true);
                 return;
            }

            if (password !== confirmPassword) {
                document.getElementById("password_error").style.display = "block";
                setStatus("Error: Stored Passwords do not match.", true);
                return;
            }
            if (masterPassword.length === 0) {
                 setStatus("Error: Master Password is required to encrypt the entry.", true);
                 document.getElementById("master_password").focus();
                 return;
            }
            
            document.getElementById("password_error").style.display = "none";

            try {
                let entryName = '';
                let dataToEncrypt = {};
                
                if (activeMode === 'website') {
                    entryName = document.getElementById('website').value;
                    dataToEncrypt.website = entryName;
                    dataToEncrypt.username = document.getElementById('username').value; 
                } else {
                    entryName = document.getElementById('name').value;
                    dataToEncrypt.name = entryName;
                    dataToEncrypt.content = document.getElementById('content').value;
                }
                
                dataToEncrypt.password = password; 
                dataToEncrypt.last_changed = getCurrentTimestampISO(); 
                dataToEncrypt.metadata = getSafeMetadata(); 

                const jsonData = JSON.stringify(dataToEncrypt);
                
                // NEW: encryptData now handles key derivation and salt generation
                const encryptedPackage = await encryptData(masterPassword, jsonData);

                const [owner, repo] = ghConfig.repository.split('/'); 
                const workflowId = ghConfig.workflow_name; 

                const githubEndpoint = `https://api.github.com/repos/${owner}/${repo}/actions/workflows/${workflowId}/dispatches`;

                const bodyToSend = JSON.stringify({
                    ref: 'main', 
                    inputs: {
                        name: entryName,
                        category: activeMode,
                        encrypted_data: JSON.stringify({
                            ciphertext: encryptedPackage.ciphertext,
                            iv: encryptedPackage.iv,
                            // NOTE: 'tag' is removed
                            salt: encryptedPackage.salt 
                        })
                    }
                });

                const headersToSend = {
                    'Content-Type': 'application/json',
                    'Accept': 'application/vnd.github.v3+json',
                    'Authorization': `token ${token}`
                };

                const response = await fetch(githubEndpoint, {
                    method: 'POST',
                    headers: headersToSend,
                    body: bodyToSend
                });

                if (response.status === 204) {
                    setStatus(`Entry successfully encrypted and sent. GitHub Workflow Dispatch triggered.`, false);
                    event.target.reset(); 
                } else {
                    const errorText = await response.json().catch(() => response.text());
                    throw new Error(`GitHub API call failed. Status: ${response.status}. Message: ${JSON.stringify(errorText)}`);
                }

            } catch (error) {
                console.error("Submission failed:", error);
                setStatus(`Error during submission: ${error.message || 'Check console for details.'}`, true);
            }
        }


        // --- LISTING & UI UTILITIES (Unchanged) ---

        function switchMenu(menu) {
            document.getElementById('form_view').style.display = menu === 'entry' ? 'block' : 'none';
            document.getElementById('list_view').style.display = menu === 'list' ? 'block' : 'none';
            
            document.getElementById('btn_entry').classList.toggle('active', menu === 'entry');
            document.getElementById('btn_list').classList.toggle('active', menu === 'list');
            
            if (menu === 'list') {
                refreshSecretList();
            }
        }
        
        function filterSecretList() {
            const searchInput = document.getElementById('search_input').value.toLowerCase();
            const listItems = document.querySelectorAll('#secret_list_content .secret-item');
            
            listItems.forEach(item => {
                const nameElement = item.querySelector('.secret-item-info strong');
                const nameText = nameElement ? nameElement.textContent.toLowerCase() : '';
                
                if (nameText.includes(searchInput)) {
                    item.style.display = 'flex'; 
                } else {
                    item.style.display = 'none'; 
                }
            });
        }
        
        function populateEntryForm(data) {
            switchMenu('entry');
            
            document.getElementById('password').value = '';
            document.getElementById('confirm_password').value = '';
            checkPasswordStrength('');
            
            if (data.website) {
                switchMode('website');
                document.getElementById('website').value = data.website;
                document.getElementById('username').value = data.username || '';
            } else if (data.content) {
                switchMode('text');
                document.getElementById('name').value = data.name || '';
                document.getElementById('content').value = data.content || '';
            }
            
            document.getElementById('password').value = data.password || ''; 
            document.getElementById('confirm_password').value = data.password || ''; 
            
            checkPasswordStrength(document.getElementById('password').value);
            
            setStatus("Entry loaded into form. Make your edits and click 'Encrypt & Send' to overwrite.", false);
        }

        async function refreshSecretList() {
            if (!config) {
                 setStatus("Configuration not loaded.", true);
                 return;
            }
            const ghConfig = config.github_config;
            const [owner, repo] = ghConfig.repository.split('/'); 
            const listContentDiv = document.getElementById('secret_list_content');
            listContentDiv.innerHTML = '<p style="padding-left: 15px;">Loading secrets...</p>';
            setStatus('Fetching list of stored secrets...', false);
            
            document.getElementById('secret_details').style.display = 'none';
            window.currentSecretPath = null; 
            document.getElementById('search_input').value = ''; 

            const tokenInput = document.getElementById('github_token_input').value.trim();
            const token = tokenInput; 

            if (!token || token === 'YOUR_PERSONAL_ACCESS_TOKEN') {
                listContentDiv.innerHTML = '<p class="error-message" style="display:block; padding-left: 15px;">Cannot load list: Please enter or verify your **GitHub Token** above.</p>';
                setStatus("Listing failed: GitHub token is missing.", true);
                return;
            }

            const listEndpoint = `https://api.github.com/repos/${owner}/${repo}/contents/secrets?ref=main`;

            try {
                const response = await fetch(listEndpoint, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/vnd.github.v3+json',
                        'Authorization': `token ${token}`
                    }
                });

                if (response.status === 404) {
                    listContentDiv.innerHTML = '<p style="padding-left: 15px;">The "secrets" directory does not exist yet. Please add an entry first.</p>';
                    setStatus('No secrets directory found.', false);
                    return;
                }
                
                if (!response.ok) {
                    const errorText = await response.json().catch(() => response.text());
                    throw new Error(`GitHub API call failed (Status ${response.status}): ${JSON.stringify(errorText)}`);
                }

                const contents = await response.json();
                
                let listHTML = '';
                const secretCategories = contents.filter(item => item.type === 'dir' && item.name !== 'secrets_trash');

                if (secretCategories.length === 0) {
                    listHTML = '<p style="padding-left: 15px;">No active secret categories found.</p>';
                } else {
                    for (const category of secretCategories) {
                        listHTML += `<h4>üìÅ ${category.name.toUpperCase()}</h4><ul>`;
                        
                        const subContentsResponse = await fetch(category.url, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/vnd.github.v3+json',
                                'Authorization': `token ${token}`
                            }
                        });
                        
                        if (!subContentsResponse.ok) continue;

                        const subContents = await subContentsResponse.json();
                        
                        const secretFiles = subContents.filter(item => item.type === 'file' && item.name.endsWith('.txt'));

                        if (secretFiles.length === 0) {
                             listHTML += `<li><p style="font-size: 0.9em; padding-left: 10px; color: #999;">No secrets found in ${category.name}.</p></li>`;
                        } else {
                            secretFiles.forEach(file => {
                                const fileName = file.name.replace('.txt', '').replace(/_/g, ' ');
                                const fullPath = file.path; 
                                
                                listHTML += `
                                    <li class="secret-item" data-name="${fileName.toLowerCase()}"> 
                                        <div class="secret-item-info">
                                            <strong>${fileName}</strong> 
                                            <span>(${category.name})</span>
                                        </div>
                                        <button class="inline-decrypt-button" 
                                                onclick="decryptSecretFromList('${file.url}', '${fileName}', '${fullPath}')">
                                            üîì View
                                        </button>
                                    </li>`;
                            });
                        }
                        listHTML += `</ul>`;
                    }
                }
                
                listContentDiv.innerHTML = listHTML;
                setStatus(`Successfully loaded secrets.`, false);
                
            } catch (error) {
                console.error("Error fetching secret list:", error);
                listContentDiv.innerHTML = '<p class="error-message" style="display:block; padding-left: 15px;">Error loading secrets. Check your token permissions (need **repo** or **contents** scope).</p>';
                setStatus(`Error listing secrets: ${error.message}`, true);
            }
        }

        async function deleteSecret() {
            if (!window.currentSecretPath) {
                alert("Error: No secret is currently selected for archiving.");
                return;
            }

            const confirmDelete = confirm(`Are you absolutely sure you want to archive (soft-delete) the secret at path: ${window.currentSecretPath}? It will be moved to secrets_trash/ directory and committed to GitHub.`);
            if (!confirmDelete) {
                return;
            }

            if (!config) { setStatus("Configuration not available. Please refresh.", true); return; }
            const ghConfig = config.github_config;
            const [owner, repo] = ghConfig.repository.split('/'); 
            
            const workflowId = ghConfig.delete_workflow_name; 

            const tokenInput = document.getElementById('github_token_input').value.trim();
            const token = tokenInput; 

            if (!workflowId || workflowId === 'YOUR_DELETE_WORKFLOW_NAME') {
                 setStatus("Configuration Error: delete_workflow_name field in config.json must be set (e.g., delete.yml).", true);
                 return;
            }


            setStatus(`Attempting to archive secret: ${window.currentSecretPath}...`, false);

            try {
                const githubEndpoint = `https://api.github.com/repos/${owner}/${repo}/actions/workflows/${workflowId}/dispatches`;

                const bodyToSend = JSON.stringify({
                    ref: 'main', 
                    inputs: {
                        file_path: window.currentSecretPath
                    }
                });

                const headersToSend = {
                    'Content-Type': 'application/json',
                    'Accept': 'application/vnd.github.v3+json',
                    'Authorization': `token ${token}`
                };

                const response = await fetch(githubEndpoint, {
                    method: 'POST',
                    headers: headersToSend,
                    body: bodyToSend
                });

                if (response.status === 204) {
                    setStatus(`Archival request successfully sent for ${window.currentSecretPath}. Refresh the list in a few moments to confirm removal.`, false);
                    document.getElementById('secret_details').style.display='none';
                    window.currentSecretPath = null;
                } else {
                    const errorText = await response.json().catch(() => response.text());
                    throw new Error(`GitHub Archive API call failed. Status: ${response.status}. Message: ${JSON.stringify(errorText)}`);
                }

            } catch (error) {
                console.error("Archiving failed:", error);
                setStatus(`Error during archiving: ${error.message || 'Check console for details.'}`, true);
            }
        }


        // --- DECRYPTION FUNCTION ---
        async function decryptSecretFromList(fileUrl, entryName, fullPath) {
             const masterPassword = document.getElementById("master_password").value;
             const decryptionOutput = document.getElementById('decryption_output');
             const detailsDiv = document.getElementById('secret_details');
             const editButton = document.getElementById('edit_button');
             const deleteButton = document.getElementById('delete_button');
             const ghConfig = config.github_config;
             
             // --- SET GLOBAL PATH AND UI ---
             window.currentSecretPath = fullPath;
             document.getElementById('selected_secret_name').textContent = entryName;
             detailsDiv.style.display = 'block';
             editButton.style.display = 'none'; 
             deleteButton.style.display = 'none'; 
             decryptionOutput.innerHTML = ''; 
             
             if (masterPassword.length === 0) {
                 decryptionOutput.innerHTML = '<p class="error-message" style="display:block;">Master Password is required to decrypt the content. Please enter it above.</p>';
                 return;
             }
             
             const tokenInput = document.getElementById('github_token_input').value.trim();
             const token = tokenInput; 
             
             if (!token || token === 'YOUR_PERSONAL_ACCESS_TOKEN') {
                 decryptionOutput.innerHTML = '<p class="error-message" style="display:block;">GitHub Token is required to fetch the encrypted file.</p>';
                 return;
             }

             decryptionOutput.innerHTML = '<p>Fetching and attempting decryption...</p>';
             setStatus(`Fetching and decrypting secret: ${entryName}...`, false);

             try {
                // 1. Fetch the encrypted content from GitHub
                const response = await fetch(fileUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/vnd.github.v3.raw', 
                        'Authorization': `token ${token}`
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch file content (Status ${response.status})`);
                }
                
                const encryptedContentJson = await response.text();
                const encryptedPackage = JSON.parse(encryptedContentJson);
                
                if (!encryptedPackage.iv || !encryptedPackage.ciphertext) {
                     throw new Error("Encrypted data structure is incomplete (missing IV or Ciphertext). File corrupted.");
                }
                
                // Check for salt (required for new stateless files)
                if (!encryptedPackage.salt) {
                     throw new Error("Missing 'salt' in file. File was encrypted in a previous, incompatible version.");
                }
                
                // 2. Derive the Decryption Key (only cipherKey)
                const { cipherKey } = await deriveKeys(masterPassword, new Uint8Array(encryptedPackage.salt)); 
                 
                // 3. Decrypt the data (Decryption will fail if GCM tag is invalid)
                const decryptedJsonString = await decryptData(
                    cipherKey, 
                    encryptedPackage.iv, 
                    encryptedPackage.ciphertext
                );
                 
                // 4. Parse and display the result
                const decryptedDataObject = JSON.parse(decryptedJsonString);
                
                // --- Display Logic ---
                const container = document.createElement('div');
                const integrityMessage = encryptedPackage.tag ? 'NOTE: Legacy file with redundant tag detected.' : 'AES-GCM tag verified.';
                container.innerHTML = `<p class="status-success" style="padding: 10px; margin-bottom: 10px; font-weight: 500;">Decryption successful! (${integrityMessage})</p>`;
                const contentBox = document.createElement('div');
                contentBox.className = 'content-box';
                
                function appendDecryptedField(label, value) {
                    const fieldDiv = document.createElement('div');
                    fieldDiv.className = 'decrypted-field';
                    
                    const fieldInfo = document.createElement('div');
                    fieldInfo.className = 'field-info';
                    
                    const labelSpan = document.createElement('span');
                    labelSpan.className = 'field-label';
                    labelSpan.textContent = label + ':';
                    
                    const valueSpan = document.createElement('span');
                    valueSpan.className = 'field-value';
                    valueSpan.textContent = value;
                    
                    fieldInfo.appendChild(labelSpan);
                    fieldInfo.appendChild(valueSpan);

                    fieldDiv.appendChild(fieldInfo);
                    fieldDiv.appendChild(createCopyButton(value));
                    
                    contentBox.appendChild(fieldDiv);
                }


                if (decryptedDataObject.website) {
                    appendDecryptedField('Website', decryptedDataObject.website);
                    appendDecryptedField('Login/User', decryptedDataObject.username || '[N/A]');
                    appendDecryptedField('Password', decryptedDataObject.password);
                } 
                else if (decryptedDataObject.content) {
                    appendDecryptedField('Title', decryptedDataObject.name || '[N/A]');
                    appendDecryptedField('Password', decryptedDataObject.password);

                    const contentDiv = document.createElement('div');
                    contentDiv.style.marginTop = '15px';
                    
                    const contentLabel = document.createElement('span');
                    contentLabel.className = 'field-label';
                    contentLabel.style.width = 'auto';
                    contentLabel.style.display = 'block';
                    contentLabel.textContent = 'Content:';
                    contentDiv.appendChild(contentLabel);
                    
                    const preElement = document.createElement('pre');
                    preElement.style.marginTop = '5px';
                    preElement.style.background = '#fff';
                    preElement.style.border = '1px dashed #ccc';
                    preElement.style.padding = '10px';
                    preElement.style.fontSize = '0.9em';
                    preElement.textContent = decryptedDataObject.content;
                    contentDiv.appendChild(preElement);
                    
                    const copyBtnContainer = document.createElement('div');
                    copyBtnContainer.style.textAlign = 'right';
                    copyBtnContainer.appendChild(createCopyButton(decryptedDataObject.content));
                    contentDiv.appendChild(copyBtnContainer);
                    
                    contentBox.appendChild(contentDiv);
                } else {
                    contentBox.innerHTML = `
                        <p class="error-message">Unknown structure detected, displaying raw JSON:</p>
                        <pre>${JSON.stringify(decryptedDataObject, null, 2)}</pre>
                    `;
                }
                
                const changedTimestamp = decryptedDataObject.last_changed;
                if (changedTimestamp) {
                     let displayValue = changedTimestamp;
                     try {
                        if (changedTimestamp.includes('T') && changedTimestamp.includes('Z')) {
                             displayValue = new Intl.DateTimeFormat(navigator.language, {
                                 year: 'numeric', month: 'short', day: 'numeric',
                                 hour: '2-digit', minute: '2-digit', second: '2-digit',
                                 timeZoneName: 'short'
                             }).format(new Date(changedTimestamp));
                             displayValue += ' (Client Local Time)';
                        }
                     } catch (e) {
                         // Fallback
                     }
                     appendDecryptedField('Last Changed', displayValue);
                } else {
                     appendDecryptedField('Last Changed', '[Unknown]');
                }

                if (decryptedDataObject.metadata) {
                    contentBox.innerHTML += `
                        <details style="margin-top: 15px;">
                            <summary style="font-size: 0.9em; font-weight: 500; color: var(--text-medium); cursor: pointer;">Metadata</summary>
                            <p style="font-size: 0.8em; margin: 5px 0 0 10px; color: #999;">
                                Saved: ${decryptedDataObject.metadata.saveTime}<br>
                                Browser: ${decryptedDataObject.metadata.browser}<br>
                                Platform: ${decryptedDataObject.metadata.platform}
                            </p>
                        </details>
                    `;
                }

                container.appendChild(contentBox);
                decryptionOutput.appendChild(container);
                
                setStatus(`Decryption successful for "${entryName}".`, false);
                
                editButton.style.display = 'inline-block';
                editButton.onclick = () => populateEntryForm(decryptedDataObject);

                deleteButton.style.display = 'inline-block';
                 
             } catch (error) {
                 console.error("Decryption failed:", error);
                 let errorMessage = error.message;
                 if (errorMessage.includes("Authentication failed") || error.name === "OperationError") {
                    // OperationError is what WebCrypto throws on GCM tag verification failure
                    errorMessage = "Decryption failed! The **Master Password** is incorrect or the data is corrupted.";
                 } else if (errorMessage.includes("Missing 'salt'")) {
                     errorMessage = "Decryption failed! This file is from an old, incompatible version.";
                 } else if (errorMessage.includes("Failed to fetch file content")) {
                    errorMessage = `Failed to fetch file: Check your GitHub Token permissions or if the file exists.`;
                 }
                 decryptionOutput.innerHTML = `<p class="error-message" style="display:block; padding: 10px; border: 1px solid #f5c6cb; border-radius: 4px; background-color: #fff; font-weight: normal;">${errorMessage}</p>`;
                 setStatus(`Decryption failed for "${entryName}".`, true);
             }
        }
        // --- END DECRYPTION FUNCTION ---

        // --- UI Initialization and Utility Functions (REST UNCHANGED) ---
        

        function generatePassphrase() { 
            const numWords = Math.floor(Math.random() * 3) + 3; 
            let passphrase = [];
            for (let i = 0; i < numWords; i++) {
                const randomIndex = Math.floor(Math.random() * DIC.length);
                passphrase.push(DIC[randomIndex]);
            }
            const finalPassphrase = passphrase.join('-'); 
            document.getElementById("password").value = finalPassphrase;
            document.getElementById("confirm_password").value = finalPassphrase;
            checkPasswordStrength(finalPassphrase);
            copyToClipboard('password');
        }

        function switchMode(mode) { 
            const websiteFields = document.getElementById('website_fields');
            const websiteInputs = websiteFields.querySelectorAll('input');
            const textFields = document.getElementById('text_fields');
            const textInputs = textFields.querySelectorAll('input, textarea');
            const btnWebsite = document.getElementById('btn_website');
            const btnText = document.getElementById('btn_text');

            if (mode === 'website') {
                websiteFields.style.display = 'block';
                textFields.style.display = 'none';
                btnWebsite.classList.add('active');
                btnText.classList.remove('active');
                websiteInputs.forEach(input => input.disabled = false);
                textInputs.forEach(input => input.disabled = true);
            } else if (mode === 'text') {
                websiteFields.style.display = 'none';
                textFields.style.display = 'block';
                btnWebsite.classList.remove('active');
                btnText.classList.add('active');
                websiteInputs.forEach(input => input.disabled = true);
                textInputs.forEach(input => input.disabled = false);
            }
        }

        function togglePasswordVisibility(inputId) { 
            const input = document.getElementById(inputId);
            const button = input.parentElement.querySelector(`button[onclick*="${inputId}"]`);
            if (input.type === "password") {
                input.type = "text";
                button.innerHTML = 'üëì';
                button.title = "Hide Password";
            } else {
                input.type = "password";
                button.innerHTML = 'üëÅÔ∏è';
                button.title = "Show Password";
            }
        }
        
        function generatePassword() { 
            const length = 12;
            const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=";
            let password = "";
            for (let i = 0; i < length; i++) {
                const randomIndex = Math.floor(Math.random() * charset.length);
                password += charset[randomIndex];
            }
            document.getElementById("password").value = password;
            document.getElementById("confirm_password").value = password;
            checkPasswordStrength(password);
            copyToClipboard('password');
        }

        function getStrengthMetrics(password) {
            let score = 0;
            if (password.length >= 8) score += 1;
            if (password.length >= 15) score += 1;
            if (/[a-z]/.test(password)) score += 1;
            if (/[A-Z]/.test(password)) score += 1;
            if (/\d/.test(password)) score += 1;
            if (/[^a-zA-Z0-9\s]/.test(password)) score += 1;
            
            if (password.length === 0) {
                return { percent: 0, color: '#eee', text: '' };
            } else if (score < 3) {
                return { percent: 30, color: 'weak', text: 'Weak' };
            } else if (score < 5) {
                return { percent: 60, color: 'medium', text: 'Medium' };
            } else {
                return { percent: 100, color: 'strong', text: 'Strong' };
            }
        }

        function checkPasswordStrength(p) { 
            const password = p || document.getElementById("password").value;
            const bar = document.getElementById("password_bar");
            const strengthDisplay = document.getElementById("strength_display");
            
            const metrics = getStrengthMetrics(password);
            
            bar.style.width = metrics.percent + '%';
            bar.className = metrics.color; 
            strengthDisplay.textContent = metrics.text;
        }
        
        async function copyStringValue(value, buttonElement) {
            try {
                // Use modern Clipboard API to avoid selecting the input field
                await navigator.clipboard.writeText(value);
                
                const originalText = buttonElement.innerHTML;
                buttonElement.innerHTML = '‚úîÔ∏è Copied!';
                setTimeout(() => { buttonElement.innerHTML = originalText; }, 1500);

            } catch (err) {
                console.error('Failed to copy: ', err);
                alert('Could not copy to clipboard. Ensure your browser grants clipboard access.');
            }
        }

        function createCopyButton(value) {
            const button = document.createElement('button');
            button.className = 'copy-utility-button';
            button.innerHTML = 'üìã Copy';
            button.title = 'Copy value to clipboard';
            button.onclick = (e) => {
                e.stopPropagation(); 
                copyStringValue(value, button);
            };
            return button;
        }

        function copyToClipboard(inputId) { 
            const input = document.getElementById(inputId);
            // NOTE: Keep old method for inputs without a dedicated copy button for simplicity
            input.select();
            input.setSelectionRange(0, 99999); 
            navigator.clipboard.writeText(input.value)
                .then(() => {
                    // Find the copy button associated with this input
                    const copyButton = input.parentElement.querySelector(`button[onclick*="copyToClipboard('${inputId}')"]`);
                    if(copyButton) {
                        const originalText = copyButton.innerHTML;
                        copyButton.innerHTML = '‚úîÔ∏è Copied!';
                        setTimeout(() => { copyButton.innerHTML = originalText; }, 1500);
                    } else {
                         alert(`Copied ${inputId.replace('_', ' ')} to clipboard!`);
                    }
                })
                .catch(err => {
                    console.error('Failed to copy: ', err);
                    alert('Could not copy to clipboard. Please try manually.');
                });
        }

        window.onload = async function() {
            // 1. Load configuration (and automatically fill token if present in config.json)
            await loadConfig();
            
            if (config) {
                // 2. Load locally stored credentials (GitHub Token ONLY)
                await loadStoredCredentials(); 
                
                // 3. UI Setup
                switchMenu('entry'); 
                switchMode('website'); 
                checkPasswordStrength();
            }
        };
    </script>
</body>
</html>