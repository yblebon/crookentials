<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure Vault - Entry & Listing</title>
    <style>
        /* BASE STYLES & TYPOGRAPHY */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: #f0f2f5; /* Light, modern background */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top */
            min-height: 100vh;
            padding-top: 50px;
            margin: 0;
        }
        .container {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); /* Subtle elevation */
            width: 700px; /* Slightly wider container */
            max-width: 95%;
        }
        h2 {
            text-align: center;
            margin-bottom: 25px;
            color: #333;
            font-weight: 600;
        }
        h3, h4 {
            color: #444;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
            margin-bottom: 15px;
        }
        .form-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            color: #555;
            font-size: 0.95em;
        }
        
        /* INPUT AND BUTTON BASE STYLES */
        input:not([type="checkbox"]), textarea {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            box-sizing: border-box;
            transition: border-color 0.2s, box-shadow 0.2s;
            font-size: 1em;
        }
        input:focus, textarea:focus {
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
            outline: none;
        }
        textarea {
            min-height: 100px;
            resize: vertical; 
        }

        /* UTILITY BUTTONS (Eye, Copy, Generate) */
        .utility-button, button.copy-utility-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0 8px;
            font-size: 1.1em;
            line-height: 1; 
            color: #888;
            transition: color 0.2s;
        }
        .utility-button:hover, button.copy-utility-button:hover {
            color: #007bff;
        }
        .input-utility-group {
            display: flex;
            align-items: center;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding-right: 5px; 
            background-color: #fff;
        }
        .input-utility-group input, .input-utility-group textarea {
            border: none;
            padding: 10px 12px;
        }
        
        /* PRIMARY ACTION BUTTONS (Submit, Refresh) */
        button[type="submit"], 
        .list-utility-row button, 
        .password-group button:not(.utility-button) {
            padding: 10px 15px;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            margin-left: 5px;
            transition: background-color 0.2s, box-shadow 0.2s;
        }
        
        button[type="submit"] {
            width: 100%;
            background-color: #007bff;
            margin-top: 20px; 
        }
        button[type="submit"]:hover {
            background-color: #0056b3;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        /* GENERATE BUTTONS */
        .password-group button:not(.utility-button) {
            background-color: #17a2b8; /* Info blue */
        }
        .password-group button:not(.utility-button):hover {
            background-color: #138496;
        }
        .list-utility-row button {
            background-color: #6c757d; /* Secondary gray */
        }
        .list-utility-row button:hover {
            background-color: #5a6268;
        }


        /* MODE AND MENU SWITCHES */
        .menu-switch, .mode-switch {
            display: flex;
            justify-content: space-around;
            margin-bottom: 25px;
            border-radius: 6px;
            overflow: hidden;
            background-color: #e9ecef; /* Light gray background */
        }
        .menu-switch button, .mode-switch button {
            flex: 1;
            padding: 12px 10px;
            border: none;
            background-color: transparent;
            color: #495057;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            font-weight: 500;
        }
        .menu-switch button.active, .mode-switch button.active {
            background-color: #007bff;
            color: white;
            font-weight: 600;
        }
        .menu-switch button:not(.active):hover, .mode-switch button:not(.active):hover {
            background-color: #dee2e6;
        }

        /* STATUS & ERROR MESSAGES */
        #status_message {
            text-align: center;
            padding: 12px;
            margin-bottom: 20px;
            border-radius: 6px;
            display: none;
            font-weight: 600;
            border: 1px solid;
            transition: opacity 0.3s ease;
        }
        .status-success {
            background-color: #d4edda;
            color: #155724;
            border-color: #c3e6cb;
        }
        .status-error, .error-message {
            background-color: #f8d7da;
            color: #721c24;
            border-color: #f5c6cb;
        }
        .error-message {
            padding: 8px;
            border-radius: 4px;
            margin-top: 10px;
            font-size: 0.9em;
            display: none;
            background-color: transparent;
            border: none;
            color: #dc3545; /* Standard danger red */
        }

        /* LISTING STYLES */
        #secret_list_content {
            margin-top: 15px;
            padding: 0 10px;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            max-height: 400px;
            overflow-y: auto;
            background-color: #fff;
        }
        #secret_list_content h4 {
            border-bottom: none;
            margin-top: 15px;
            padding-bottom: 0;
            font-size: 1.1em;
            color: #007bff; /* Primary color for categories */
        }
        #secret_list_content ul {
            list-style: none;
            padding: 0;
            margin-bottom: 20px;
        }
        .secret-item {
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #eee;
        }
        .secret-item:last-child {
            border-bottom: none;
        }
        .secret-item-info strong {
            color: #333;
            font-size: 1em;
        }
        .secret-item-info span {
            font-size: 0.85em;
            color: #999;
            margin-left: 10px;
            font-style: italic;
        }
        .inline-decrypt-button {
            padding: 8px 15px;
            background-color: #28a745; /* Success green */
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
        }
        .inline-decrypt-button:hover {
            background-color: #1e7e34;
        }
        .list-utility-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            gap: 10px;
        }
        #search_input {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 6px;
        }

        /* DECRYPTION DETAILS VIEW */
        #secret_details {
            margin-top: 25px;
            border-top: 2px solid #007bff; /* Separator color */
            padding-top: 20px;
        }
        .details-viewer-header {
             display: flex; 
             justify-content: space-between; 
             align-items: center;
             margin-bottom: 15px;
        }
        .details-viewer-header h4 {
             border-bottom: none;
             margin-bottom: 0;
             font-weight: 600;
             color: #007bff;
        }
        .details-viewer-header span {
            font-style: italic;
            font-weight: normal;
            color: #333;
        }
        
        .details-viewer-header button {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            margin-left: 10px;
            font-weight: 500;
        }
        .details-viewer-header button.edit-button {
            background-color: #ffc107; /* Warning yellow */
            color: #343a40;
        }
        .details-viewer-header button.edit-button:hover {
            background-color: #e0a800;
        }
        .details-viewer-header button.delete-button {
            background-color: #dc3545; /* Danger red */
            color: white;
        }
        .details-viewer-header button.delete-button:hover {
            background-color: #c82333;
        }
        .details-viewer-header #close_details_button {
            background-color: #6c757d;
            color: white;
        }
        .details-viewer-header #close_details_button:hover {
            background-color: #5a6268;
        }

        /* Decryption Output Styling */
        #decryption_output pre, #decryption_output div.content-box {
            white-space: pre-wrap;
            word-wrap: break-word;
            background: #f8f9fa; /* Very light background for content box */
            padding: 15px; 
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }
        .decrypted-field {
            margin-bottom: 10px;
            padding: 8px 0;
            border-bottom: 1px dotted #ccc;
            display: flex; 
            align-items: center;
            justify-content: space-between; 
        }
        .decrypted-field:last-child {
            border-bottom: none;
        }
        .field-info {
            display: flex;
            align-items: baseline;
            flex-grow: 1;
        }
        .field-label {
            font-weight: 600;
            color: #333;
            width: 120px; /* Slightly wider label area */
            min-width: 120px;
            margin-right: 15px;
            font-size: 0.9em;
        }
        .field-value {
             font-family: monospace;
             background-color: #fff;
             padding: 4px 8px;
             border-radius: 4px;
             border: 1px solid #ddd;
             display: inline-block;
             max-width: 70%;
             overflow: hidden;
             text-overflow: ellipsis;
             flex-grow: 1;
             color: #333;
             font-size: 0.9em;
        }
        button.copy-utility-button {
            background: #e9ecef;
            border: 1px solid #ddd;
            padding: 5px 10px;
            font-size: 0.85em;
            border-radius: 4px;
            margin-left: 10px;
            color: #333;
        }
        button.copy-utility-button:hover {
            background: #dee2e6;
            color: #007bff;
        }

        /* Strength Meter (Unchanged but ensuring colors fit) */
        #password_meter {
            height: 8px;
            border-radius: 4px;
            margin-top: 5px;
            background: #eee;
            overflow: hidden;
        }
        .strength-text {
            font-size: 0.85em;
            text-align: right;
            margin-top: 2px;
            font-weight: 500;
            color: #666;
        }
        .weak { background-color: #dc3545; }
        .medium { background-color: #ffc107; }
        .strong { background-color: #28a745; }
        .password-group {
             display: flex;
             align-items: center;
             gap: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>Secure Vault</h2>
        
        <div id="status_message"></div>

        <div class="menu-switch">
            <button type="button" id="btn_entry" class="active" onclick="switchMenu('entry')">‚ûï New Entry</button>
            <button type="button" id="btn_list" onclick="switchMenu('list')">üìÑ List Secrets</button>
        </div>

        <div class="form-group" id="global_keys">
            <label for="master_password">üîê Entry Decryption Master Password (Auto-Clears):</label>
            <div class="input-utility-group">
                <input type="password" id="master_password" name="master_password" placeholder="Enter your master key (required for encrypt/decrypt)"> 
                <button type="button" class="utility-button" onclick="togglePasswordVisibility('master_password')" title="Show Entry Decryption Master Password">&#x1F441;</button>
            </div>

            <label for="github_token_input" style="margin-top: 15px;">üë§ GitHub Personal Access Token (PAT):</label>
            <div class="input-utility-group">
                <input type="password" id="github_token_input" name="github_token_input" placeholder="Token from config.json (or enter a temporary one)"> 
                <button type="button" class="utility-button" onclick="togglePasswordVisibility('github_token_input')" title="Show Token">&#x1F441;</button>
            </div>
            
            <p id="key_status_hint" style="margin-top: 10px; font-size: 0.85em; color: #007bff; display: none;">
                üîë **First Use:** This password will also initialize your secure Master Key data.
            </p>
        </div>
        
        <hr style="border: 0; border-top: 1px solid #eee; margin: 30px 0;">

        <div id="form_view">
            <h3>New Secure Entry</h3>
            <div class="mode-switch">
                <button type="button" id="btn_website" class="active" onclick="switchMode('website')">üåê Website/Login</button>
                <button type="button" id="btn_text" onclick="switchMode('text')">üìù Secure Note</button>
            </div>

            <form action="#" method="post" onsubmit="return validatePassword(event)">
                <div id="website_fields" class="form-mode-group">
                    <div class="form-group">
                        <label for="website">Website URL:</label>
                        <input type="text" id="website" name="website" placeholder="e.g., example.com" required>
                    </div>
                    <div class="form-group">
                        <label for="username">Username/Email (Login):</label>
                        <div class="input-utility-group">
                            <input type="text" id="username" name="username" placeholder="Enter your username or email" required>
                            <button type="button" class="utility-button" onclick="copyToClipboard('username')" title="Copy Username">&#x2398;</button>
                        </div>
                    </div>
                </div>

                <div id="text_fields" class="form-mode-group" style="display: none;">
                     <div class="form-group">
                        <label for="name">Name/Title:</label>
                        <input type="text" id="name" name="name" placeholder="e.g., Secure Note Title" required disabled>
                    </div>
                    <div class="form-group">
                        <label for="content">Content/Note:</label>
                        <div class="input-utility-group">
                            <textarea id="content" name="content" placeholder="Enter your secret text or note" required disabled></textarea>
                             <button type="button" class="utility-button" onclick="copyToClipboard('content')" title="Copy Note Content">&#x2398;</button>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label for="password">Stored Password:</label>
                    <div class="password-group">
                        <div class="input-utility-group" style="flex-grow: 1;">
                            <input type="password" id="password" name="password" placeholder="Enter or generate a password" onkeyup="checkPasswordStrength()" required>
                            <button type="button" class="utility-button" onclick="togglePasswordVisibility('password')" title="Show Password">&#x1F441;</button>
                            <button type="button" class="utility-button" onclick="copyToClipboard('password')" title="Copy Password">&#x2398;</button>
                        </div>
                        <button type="button" onclick="generatePassphrase()" title="Generate random passphrase">Words</button> 
                        <button type="button" onclick="generatePassword()" title="Generate random mixed-character password">Gen</button>
                    </div>
                    
                    <div id="password_meter">
                        <div id="password_bar"></div>
                    </div>
                    <div id="strength_display" class="strength-text"></div>
                </div>

                <div class="form-group">
                    <label for="confirm_password">Confirm Stored Password:</label>
                    <div class="input-utility-group">
                        <input type="password" id="confirm_password" name="confirm_password" placeholder="Re-enter your password" required>
                        <button type="button" class="utility-button" onclick="togglePasswordVisibility('confirm_password')" title="Show Confirmation Password">&#x1F441;</button>
                    </div>
                    <p id="password_error" class="error-message">Passwords do not match!</p>
                </div>

                <button type="submit">Encrypt & Send to GitHub Action</button>
            </form>
        </div>

        <div id="list_view" style="display: none;">
            <h3>Stored Secrets List (GitHub)</h3>
            
            <div class="list-utility-row">
                <input type="text" id="search_input" placeholder="Filter secrets by name..." onkeyup="filterSecretList()">
                <button type="button" onclick="refreshSecretList()">üîÑ Refresh List</button>
            </div>

            <div id="secret_list_content">
                <p>Click "Refresh List" to load secrets from your GitHub repository.</p>
            </div>
            
            <div id="secret_details" style="display: none;">
                <div class="details-viewer-header">
                    <h4>Decrypted Details for: <span id="selected_secret_name"></span></h4>
                    <div>
                        <button id="delete_button" class="delete-button" style="display:none;" title="Permanently archive this entry" onclick="deleteSecret()">üóëÔ∏è Archive Secret</button>
                        
                        <button id="edit_button" class="edit-button" style="display:none;" title="Edit/Re-encrypt this entry">‚úèÔ∏è Edit/Re-encrypt</button>
                        <button id="close_details_button" onclick="document.getElementById('secret_details').style.display='none'">Close Viewer</button>
                    </div>
                </div>
                <div id="decryption_output" style="margin-top: 10px;">
                    <p>Select a secret and click **Decrypt** to view its contents.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration Object ---
        let config = null;
        const DIC = ["apple", "river", "cloud", "snake", "ocean", "pizza", "happy", "zebra", "music", "light", "house", "chair", "table", "phone", "plant", "green", "tiger", "earth", "dream", "robot", "magic", "ghost", "knife", "spoon", "sugar", "heart", "moon", "star", "jelly", "socks"];
        let inactivityTimer;
        
        // ** DYNAMIC TIMEOUT BASED ON CONFIGURATION **
        let INACTIVITY_TIMEOUT_MS = 5 * 60 * 1000; // Default to 5 minutes before config load

        // --- GLOBAL STATE FOR CURRENTLY DECRYPTED SECRET ---
        window.currentSecretPath = null; 

        // --- Master Password Timeout Logic ---
        
        /**
         * Clears the Master Password field and provides a status message.
         */
        function clearMasterPassword() {
            const masterInput = document.getElementById('master_password');
            if (masterInput && masterInput.value.length > 0) {
                // 1. Securely overwrite the field value
                masterInput.value = '';
                
                // 2. Ensure the type is correctly set to 'password'
                masterInput.type = 'password'; 
                
                // 3. Set a status message
                setStatus('Entry Decryption Master Password cleared due to inactivity/tab switch.', true);
            }
            if (inactivityTimer) {
                clearTimeout(inactivityTimer);
                inactivityTimer = null; // Mark as cleared
            }
        }
        
        /**
         * Starts or resets the inactivity timer.
         */
        function resetMasterPasswordTimer() {
            const masterInput = document.getElementById('master_password');
            
            // If the field is currently empty, don't start the timer.
            if (masterInput && masterInput.value.length === 0) {
                 if (inactivityTimer) {
                     clearTimeout(inactivityTimer);
                     inactivityTimer = null;
                 }
                 return;
            }

            // Clear any running timer first
            if (inactivityTimer) {
                clearTimeout(inactivityTimer);
            }
            
            // Start the new timer using the dynamically set duration
            inactivityTimer = setTimeout(clearMasterPassword, INACTIVITY_TIMEOUT_MS);
        }

        // --- Configuration Loader ---
        async function loadConfig() {
            try {
                const response = await fetch('config.json');
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                config = await response.json();
                
                // Set the DYNAMIC TIMEOUT here using the loaded config
                const timeoutMinutes = config.crypto_config.master_key_timeout_minutes;
                if (typeof timeoutMinutes === 'number' && timeoutMinutes > 0) {
                    INACTIVITY_TIMEOUT_MS = timeoutMinutes * 60 * 1000;
                    console.log(`Master Password timeout set to ${timeoutMinutes} minutes (from config.json).`);
                } else {
                    INACTIVITY_TIMEOUT_MS = 10 * 60 * 1000; // Default to 10 minutes if config is missing or invalid
                    console.warn(`Master Password timeout config missing or invalid. Defaulting to 10 minutes.`);
                }

                // Populate the GitHub Token input field's placeholder with the loaded config value
                const tokenInput = document.getElementById('github_token_input');
                if (config.github_config && config.github_config.token && config.github_config.token !== 'YOUR_PERSONAL_ACCESS_TOKEN') {
                    // Do NOT use placeholder if the token is present (security). Instead, set value.
                    // NOTE: Setting value here is acceptable for convenience but poses a minor risk. 
                    // For maximum security, this line should be REMOVED, forcing the user to paste the token every session.
                    tokenInput.placeholder = 'Loaded from config.json (Length: ' + config.github_config.token.length + ')';
                }
            } catch (error) {
                console.error("Failed to load config.json:", error);
                setStatus("FATAL ERROR: Could not load config.json. Check file path and network. (Required new fields: hmac_algo_name, hmac_hash_algo, delete_workflow_name, master_key_timeout_minutes)", true);
                throw error; 
            }
        }
        
        // --- Global Status Message Helper ---
        function setStatus(message, isError = false) {
            const statusDiv = document.getElementById('status_message');
            statusDiv.textContent = message;
            statusDiv.className = isError ? 'status-error' : 'status-success';
            statusDiv.style.display = 'block';
            setTimeout(() => { statusDiv.style.display = 'none'; }, 8000);
        }

        // --- IndexedDB Setup (Master Key) ---
        function openDB() {
            if (!config) throw new Error("Configuration not loaded yet.");
            const C = config.crypto_config;
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(C.db_name, C.db_version); 
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(C.store_name)) {
                        db.createObjectStore(C.store_name, { keyPath: 'id' });
                    }
                };
                request.onsuccess = (event) => resolve(event.target.result);
                request.onerror = (event) => {
                    setStatus('IndexedDB error (Master Key Store): ' + event.target.errorCode, true);
                    reject('IndexedDB error: ' + event.target.errorCode);
                };
            });
        }
        
        // --- Cryptography Functions ---

        async function deriveKeys(masterPassword, salt) {
            const C = config.crypto_config;
            const masterKey = await window.crypto.subtle.importKey(
                "raw", new TextEncoder().encode(masterPassword), { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]
            );
            
            const derivedBits = await window.crypto.subtle.deriveBits(
                {
                    name: "PBKDF2",
                    salt: salt,
                    iterations: C.pbkdf2_iterations,
                    hash: C.pbkdf2_hash_algo,
                },
                masterKey,
                512 
            );
            
            const derivedBitsArray = new Uint8Array(derivedBits);
            
            const cipherBits = derivedBitsArray.slice(0, 32); 
            const hmacBits = derivedBitsArray.slice(32, 64); 

            const cipherKey = await window.crypto.subtle.importKey(
                "raw", cipherBits, { name: C.key_algo_name, length: C.key_algo_length }, true, ["encrypt", "decrypt"]
            );
            
            const hmacKey = await window.crypto.subtle.importKey(
                "raw", hmacBits, { name: C.hmac_algo_name, hash: {name: C.hmac_hash_algo} }, true, ["sign", "verify"]
            );
            
            return { cipherKey, hmacKey };
        }

        async function encryptData(cipherKey, hmacKey, data) {
            const C = config.crypto_config;
            const encodedData = new TextEncoder().encode(data);
            const iv = window.crypto.getRandomValues(new Uint8Array(12)); 
            
            // 1. Encrypt
            const ciphertext = await window.crypto.subtle.encrypt(
                { name: C.key_algo_name, iv: iv }, 
                cipherKey,
                encodedData
            );
            
            // 2. Sign (HMAC) the ciphertext
            const signature = await window.crypto.subtle.sign(
                { name: C.hmac_algo_name },
                hmacKey,
                new Uint8Array(ciphertext)
            );

            return {
                ciphertext: Array.from(new Uint8Array(ciphertext)),
                iv: Array.from(iv),
                tag: Array.from(new Uint8Array(signature)) 
            };
        }

        async function decryptData(cipherKey, hmacKey, iv, ciphertext, tag) {
            const C = config.crypto_config;
            const ciphertextArray = new Uint8Array(ciphertext);
            
            // 1. Check for integrity tag
            if (!tag) {
                 console.warn("Legacy file detected: HMAC tag missing. Decryption proceeding without integrity check.");
            } else {
                 const tagArray = new Uint8Array(tag);
                 const isTagValid = await window.crypto.subtle.verify(
                     { name: C.hmac_algo_name },
                     hmacKey,
                     tagArray,
                     ciphertextArray 
                 );
                 
                 if (!isTagValid) {
                     throw new Error("Authentication failed. Invalid Master Password or corrupted data.");
                 }
            }
            
            // 2. Decrypt
            const decrypted = await window.crypto.subtle.decrypt(
                { name: C.key_algo_name, iv: new Uint8Array(iv) },
                cipherKey,
                ciphertextArray
            );
            
            return new TextDecoder().decode(decrypted);
        }
        
        // --- Master Key Storage and Utility Functions ---

        /**
         * Saves the initial salt for key derivation. Used only on first submission.
         * @param {string} masterPassword - The user's entry decryption password (used as key for saving the salt).
         */
        async function saveMasterKeyData(masterPassword) {
            if (!config) throw new Error("Configuration not loaded.");
            const C = config.crypto_config;
            const existingKeyData = await getMasterKeyData();
            if (existingKeyData) return existingKeyData; 

            try {
                // Generate a fresh, random salt
                const salt = window.crypto.getRandomValues(new Uint8Array(16)); 
                
                const db = await openDB();
                const transaction = db.transaction(C.store_name, 'readwrite');
                const store = transaction.objectStore(C.store_name);
                
                const keyData = {
                    id: C.key_id,
                    exportedKey: { type: "raw" }, 
                    salt: Array.from(salt), 
                    iterations: C.pbkdf2_iterations
                };
                
                await new Promise((resolve, reject) => {
                    const request = store.put(keyData);
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });
                
                setStatus('Master Key data (Salt) saved securely for future encryptions.', false);
                return keyData;

            } catch (error) {
                console.error("Cryptography or DB operation failed:", error);
                setStatus("An error occurred during secure key generation.", true);
                throw error;
            }
        }
        
        function getMasterKeyData() {
            if (!config) throw new Error("Configuration not loaded.");
            const C = config.crypto_config;
            return new Promise(async (resolve, reject) => {
                try {
                    const db = await openDB();
                    const store = db.transaction(C.store_name, 'readonly').objectStore(C.store_name);
                    const request = store.get(C.key_id);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => reject(event.target.error);
                } catch (error) {
                    reject(error);
                }
            });
        }
        
        function getSafeMetadata() {
            const ua = navigator.userAgent;
            let browser = 'Unknown';
            if (ua.indexOf("Chrome") > -1 && ua.indexOf("Edg") === -1) {
                browser = ua.match(/Chrome\/(\S+)/) ? ua.match(/Chrome\/(\S+)/)[0] : 'Chrome (version missing)';
            } else if (ua.indexOf("Firefox") > -1) {
                browser = ua.match(/Firefox\/(\S+)/) ? ua.match(/Firefox\/(\S+)/)[0] : 'Firefox (version missing)';
            } else if (ua.indexOf("Edg") > -1) {
                browser = ua.match(/Edg\/(\S+)/) ? ua.match(/Edg\/(\S+)/)[0] : 'Edge (version missing)';
            } else if (ua.indexOf("Safari") > -1) {
                browser = ua.match(/Version\/(\S+)/) ? ua.match(/Version\/(\S+)/)[0] + " Safari" : 'Safari (version missing)';
            }
            return {
                platform: navigator.platform,
                browser: browser,
                saveTime: new Date().toISOString()
            };
        }


        // --- FORM SUBMISSION LOGIC ---

        function getCurrentTimestampISO() {
            return new Date().toISOString();
        }


        async function validatePassword(event) {
            event.preventDefault(); 
            
            if (!config) { setStatus("Configuration not available. Please refresh.", true); return; }

            const password = document.getElementById("password").value;
            const confirmPassword = document.getElementById("confirm_password").value;
            const masterPassword = document.getElementById("master_password").value;
            const tokenInput = document.getElementById('github_token_input').value.trim();
            const activeMode = document.getElementById('btn_website').classList.contains('active') ? 'website' : 'text';
            
            const ghConfig = config.github_config;

            // Determine which token to use
            const token = tokenInput || ghConfig.token;

            if (!ghConfig.repository || !ghConfig.workflow_name || !token || token === 'YOUR_PERSONAL_ACCESS_TOKEN') {
                 setStatus("Configuration Error: GitHub repository, workflow_name, or token is missing/default.", true);
                 return;
            }

            if (password !== confirmPassword) {
                document.getElementById("password_error").style.display = "block";
                setStatus("Error: Stored Passwords do not match.", true);
                return;
            }
            if (masterPassword.length === 0) {
                 setStatus("Error: Entry Decryption Master Password is required to encrypt the entry.", true);
                 document.getElementById("master_password").focus();
                 return;
            }
            
            document.getElementById("password_error").style.display = "none";

            try {
                let keyData = await getMasterKeyData();
                
                // AUTOMATIC MASTER KEY INITIALIZATION
                if (!keyData) {
                    setStatus("First use detected. Initializing secure Master Key data...", false);
                    keyData = await saveMasterKeyData(masterPassword); 
                }
                
                const { cipherKey, hmacKey } = await deriveKeys(masterPassword, new Uint8Array(keyData.salt));

                let entryName = '';
                let dataToEncrypt = {};
                
                if (activeMode === 'website') {
                    entryName = document.getElementById('website').value;
                    dataToEncrypt.website = entryName;
                    dataToEncrypt.username = document.getElementById('username').value; 
                } else {
                    entryName = document.getElementById('name').value;
                    dataToEncrypt.name = entryName;
                    dataToEncrypt.content = document.getElementById('content').value;
                }
                
                dataToEncrypt.password = password; 
                dataToEncrypt.last_changed = getCurrentTimestampISO(); 
                dataToEncrypt.metadata = getSafeMetadata(); 

                const jsonData = JSON.stringify(dataToEncrypt);
                const encryptedPackage = await encryptData(cipherKey, hmacKey, jsonData);

                const [owner, repo] = ghConfig.repository.split('/'); 
                const workflowId = ghConfig.workflow_name; 

                const githubEndpoint = `https://api.github.com/repos/${owner}/${repo}/actions/workflows/${workflowId}/dispatches`;

                const bodyToSend = JSON.stringify({
                    ref: 'main', 
                    inputs: {
                        name: entryName,
                        category: activeMode,
                        encrypted_data: JSON.stringify({
                            ciphertext: encryptedPackage.ciphertext,
                            iv: encryptedPackage.iv,
                            tag: encryptedPackage.tag 
                        })
                    }
                });

                const headersToSend = {
                    'Content-Type': 'application/json',
                    'Accept': 'application/vnd.github.v3+json',
                    'Authorization': `token ${token}`
                };

                const response = await fetch(githubEndpoint, {
                    method: 'POST',
                    headers: headersToSend,
                    body: bodyToSend
                });

                if (response.status === 204) {
                    setStatus(`Entry successfully encrypted and sent. GitHub Workflow Dispatch triggered.`, false);
                    event.target.reset(); 
                    checkKeyStatusAndUpdateUI(); 
                    clearMasterPassword(); 
                } else {
                    const errorText = await response.json().catch(() => response.text());
                    throw new Error(`GitHub API call failed. Status: ${response.status}. Message: ${JSON.stringify(errorText)}`);
                }

            } catch (error) {
                console.error("Submission failed:", error);
                setStatus(`Error during submission: ${error.message || 'Check console for details.'}`, true);
            }
        }


        // --- LISTING FUNCTIONS ---

        function switchMenu(menu) {
            document.getElementById('form_view').style.display = menu === 'entry' ? 'block' : 'none';
            document.getElementById('list_view').style.display = menu === 'list' ? 'block' : 'none';
            
            document.getElementById('btn_entry').classList.toggle('active', menu === 'entry');
            document.getElementById('btn_list').classList.toggle('active', menu === 'list');
            
            if (menu === 'list') {
                refreshSecretList();
            }
        }
        
        /**
         * Filters the secret list items based on the search input value.
         */
        function filterSecretList() {
            const searchInput = document.getElementById('search_input').value.toLowerCase();
            const listItems = document.querySelectorAll('#secret_list_content .secret-item');
            
            listItems.forEach(item => {
                const nameElement = item.querySelector('.secret-item-info strong');
                const nameText = nameElement ? nameElement.textContent.toLowerCase() : '';
                
                if (nameText.includes(searchInput)) {
                    item.style.display = 'flex'; 
                } else {
                    item.style.display = 'none'; 
                }
            });
        }
        
        // Function to populate the form fields for editing 
        function populateEntryForm(data) {
            // 1. Switch to Entry View
            switchMenu('entry');
            
            // 2. Clear password fields
            document.getElementById('password').value = '';
            document.getElementById('confirm_password').value = '';
            checkPasswordStrength('');
            
            // 3. Populate fields based on type
            if (data.website) {
                // Website Mode
                switchMode('website');
                document.getElementById('website').value = data.website;
                document.getElementById('username').value = data.username || '';
            } else if (data.content) {
                // Text Mode
                switchMode('text');
                document.getElementById('name').value = data.name || '';
                document.getElementById('content').value = data.content || '';
            }
            
            // Populate common fields 
            document.getElementById('password').value = data.password || ''; 
            document.getElementById('confirm_password').value = data.password || ''; 
            
            // 4. Update password strength display
            checkPasswordStrength(document.getElementById('password').value);
            
            setStatus("Entry loaded into form. Make your edits and click 'Encrypt & Send' to overwrite.", false);
        }

        async function refreshSecretList() {
            if (!config) {
                 setStatus("Configuration not loaded.", true);
                 return;
            }
            const ghConfig = config.github_config;
            const [owner, repo] = ghConfig.repository.split('/'); 
            const listContentDiv = document.getElementById('secret_list_content');
            listContentDiv.innerHTML = '<p>Loading secrets...</p>';
            setStatus('Fetching list of stored secrets...', false);
            
            document.getElementById('secret_details').style.display = 'none';
            window.currentSecretPath = null; 
            document.getElementById('search_input').value = ''; 

            const tokenInput = document.getElementById('github_token_input').value.trim();
            const token = tokenInput || ghConfig.token;

            if (!token || token === 'YOUR_PERSONAL_ACCESS_TOKEN') {
                listContentDiv.innerHTML = '<p class="error-message" style="display:block;">Cannot load list: Please enter or verify your GitHub Token above.</p>';
                setStatus("Listing failed: GitHub token is missing.", true);
                return;
            }

            const listEndpoint = `https://api.github.com/repos/${owner}/${repo}/contents/secrets?ref=main`;

            try {
                const response = await fetch(listEndpoint, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/vnd.github.v3+json',
                        'Authorization': `token ${token}`
                    }
                });

                if (response.status === 404) {
                    listContentDiv.innerHTML = '<p>The "secrets" directory does not exist yet. Please add an entry first.</p>';
                    setStatus('No secrets directory found.', false);
                    return;
                }
                
                if (!response.ok) {
                    const errorText = await response.json().catch(() => response.text());
                    throw new Error(`GitHub API call failed (Status ${response.status}): ${JSON.stringify(errorText)}`);
                }

                const contents = await response.json();
                
                let listHTML = '';
                // Filter for directories (categories) inside the 'secrets' folder
                const secretCategories = contents.filter(item => item.type === 'dir' && item.name !== 'secrets_trash');

                if (secretCategories.length === 0) {
                    listHTML = '<p>No active secret categories found.</p>';
                } else {
                    for (const category of secretCategories) {
                        listHTML += `<h4>üìÅ ${category.name.toUpperCase()}</h4><ul>`;
                        
                        const subContentsResponse = await fetch(category.url, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/vnd.github.v3+json',
                                'Authorization': `token ${token}`
                            }
                        });
                        
                        if (!subContentsResponse.ok) continue;

                        const subContents = await subContentsResponse.json();
                        
                        const secretFiles = subContents.filter(item => item.type === 'file' && item.name.endsWith('.txt'));

                        if (secretFiles.length === 0) {
                             listHTML += `<li><p style="font-size: 0.9em; padding-left: 10px; color: #999;">No secrets found in ${category.name}.</p></li>`;
                        } else {
                            secretFiles.forEach(file => {
                                const fileName = file.name.replace('.txt', '').replace(/_/g, ' ');
                                const fullPath = file.path; 
                                
                                listHTML += `
                                    <li class="secret-item" data-name="${fileName.toLowerCase()}"> 
                                        <div class="secret-item-info">
                                            <strong>${fileName}</strong> 
                                            <span>(${category.name})</span>
                                        </div>
                                        <button class="inline-decrypt-button" 
                                                onclick="decryptSecretFromList('${file.url}', '${fileName}', '${fullPath}')">
                                            üîì Decrypt
                                        </button>
                                    </li>`;
                            });
                        }
                        listHTML += `</ul>`;
                    }
                }
                
                listContentDiv.innerHTML = listHTML;
                setStatus(`Successfully loaded secrets.`, false);
                
            } catch (error) {
                console.error("Error fetching secret list:", error);
                listContentDiv.innerHTML = '<p class="error-message" style="display:block;">Error loading secrets. Check your token permissions (need **repo** or **contents** scope).</p>';
                setStatus(`Error listing secrets: ${error.message}`, true);
            }
        }

        // --- DELETION/ARCHIVING FUNCTION ---
        async function deleteSecret() {
            if (!window.currentSecretPath) {
                alert("Error: No secret is currently selected for archiving.");
                return;
            }

            const confirmDelete = confirm(`Are you absolutely sure you want to archive (soft-delete) the secret at path: ${window.currentSecretPath}? It will be moved to secrets_trash/ directory and committed to GitHub.`);
            if (!confirmDelete) {
                return;
            }

            if (!config) { setStatus("Configuration not available. Please refresh.", true); return; }
            const ghConfig = config.github_config;
            const [owner, repo] = ghConfig.repository.split('/'); 
            
            const workflowId = ghConfig.delete_workflow_name; 

            const tokenInput = document.getElementById('github_token_input').value.trim();
            const token = tokenInput || ghConfig.token;

            if (!workflowId || workflowId === 'YOUR_DELETE_WORKFLOW_NAME') {
                 setStatus("Configuration Error: delete_workflow_name field in config.json must be set (e.g., delete.yml).", true);
                 return;
            }


            setStatus(`Attempting to archive secret: ${window.currentSecretPath}...`, false);

            try {
                const githubEndpoint = `https://api.github.com/repos/${owner}/${repo}/actions/workflows/${workflowId}/dispatches`;

                const bodyToSend = JSON.stringify({
                    ref: 'main', 
                    inputs: {
                        file_path: window.currentSecretPath
                    }
                });

                const headersToSend = {
                    'Content-Type': 'application/json',
                    'Accept': 'application/vnd.github.v3+json',
                    'Authorization': `token ${token}`
                };

                const response = await fetch(githubEndpoint, {
                    method: 'POST',
                    headers: headersToSend,
                    body: bodyToSend
                });

                if (response.status === 204) {
                    setStatus(`Archival request successfully sent for ${window.currentSecretPath}. Refresh the list in a few moments to confirm removal.`, false);
                    document.getElementById('secret_details').style.display='none';
                    window.currentSecretPath = null;
                } else {
                    const errorText = await response.json().catch(() => response.text());
                    throw new Error(`GitHub Archive API call failed. Status: ${response.status}. Message: ${JSON.stringify(errorText)}`);
                }

            } catch (error) {
                console.error("Archiving failed:", error);
                setStatus(`Error during archiving: ${error.message || 'Check console for details.'}`, true);
            }
        }


        // --- DECRYPTION FUNCTION ---
        async function decryptSecretFromList(fileUrl, entryName, fullPath) {
             const masterPassword = document.getElementById("master_password").value;
             const decryptionOutput = document.getElementById('decryption_output');
             const detailsDiv = document.getElementById('secret_details');
             const editButton = document.getElementById('edit_button');
             const deleteButton = document.getElementById('delete_button');
             const ghConfig = config.github_config;
             
             // --- SET GLOBAL PATH AND UI ---
             window.currentSecretPath = fullPath;
             document.getElementById('selected_secret_name').textContent = entryName;
             detailsDiv.style.display = 'block';
             editButton.style.display = 'none'; 
             deleteButton.style.display = 'none'; 
             decryptionOutput.innerHTML = ''; 
             
             if (masterPassword.length === 0) {
                 decryptionOutput.innerHTML = '<p class="error-message" style="display:block;">Master Password is required to decrypt the content. Please enter it above.</p>';
                 return;
             }
             
             const tokenInput = document.getElementById('github_token_input').value.trim();
             const token = tokenInput || ghConfig.token;
             
             if (!token || token === 'YOUR_PERSONAL_ACCESS_TOKEN') {
                 decryptionOutput.innerHTML = '<p class="error-message" style="display:block;">GitHub Token is required to fetch the encrypted file.</p>';
                 return;
             }

             decryptionOutput.innerHTML = '<p>Fetching and attempting decryption...</p>';
             setStatus(`Fetching and decrypting secret: ${entryName}...`, false);

             try {
                // 1. Fetch the encrypted content from GitHub
                const response = await fetch(fileUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/vnd.github.v3.raw', 
                        'Authorization': `token ${token}`
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch file content (Status ${response.status})`);
                }
                
                const encryptedContentJson = await response.text();
                const encryptedPackage = JSON.parse(encryptedContentJson);
                
                if (!encryptedPackage.iv || !encryptedPackage.ciphertext) {
                     throw new Error("Encrypted data structure is incomplete (missing IV or Ciphertext). File corrupted.");
                }

                // 2. Prepare the Decryption Keys
                const keyData = await getMasterKeyData();
                 if (!keyData) {
                    throw new Error("Local Master Key data is not initialized. Cannot decrypt. Please run one encryption first.");
                 }
                 
                const { cipherKey, hmacKey } = await deriveKeys(masterPassword, new Uint8Array(keyData.salt));
                 
                // 3. Decrypt the data (Verification happens inside decryptData)
                const decryptedJsonString = await decryptData(
                    cipherKey, 
                    hmacKey, 
                    encryptedPackage.iv, 
                    encryptedPackage.ciphertext,
                    encryptedPackage.tag 
                );
                 
                // 4. Parse and display the result
                const decryptedDataObject = JSON.parse(decryptedJsonString);
                
                // --- Display Logic ---
                const container = document.createElement('div');
                const integrityMessage = encryptedPackage.tag ? 'HMAC verified' : 'Legacy file - NO integrity check';
                container.innerHTML = `<p class="status-success" style="padding: 10px; margin-bottom: 10px; font-weight: 500;">Decryption successful! (${integrityMessage})</p>`;
                const contentBox = document.createElement('div');
                contentBox.className = 'content-box';
                
                function appendDecryptedField(label, value) {
                    const fieldDiv = document.createElement('div');
                    fieldDiv.className = 'decrypted-field';
                    
                    const fieldInfo = document.createElement('div');
                    fieldInfo.className = 'field-info';
                    
                    const labelSpan = document.createElement('span');
                    labelSpan.className = 'field-label';
                    labelSpan.textContent = label + ':';
                    
                    const valueSpan = document.createElement('span');
                    valueSpan.className = 'field-value';
                    valueSpan.textContent = value;
                    
                    fieldInfo.appendChild(labelSpan);
                    fieldInfo.appendChild(valueSpan);

                    fieldDiv.appendChild(fieldInfo);
                    fieldDiv.appendChild(createCopyButton(value));
                    
                    contentBox.appendChild(fieldDiv);
                }


                // Check for website/login fields
                if (decryptedDataObject.website) {
                    appendDecryptedField('Website', decryptedDataObject.website);
                    appendDecryptedField('Login/User', decryptedDataObject.username || '[N/A]');
                    appendDecryptedField('Password', decryptedDataObject.password);
                } 
                // Check for text content/note fields
                else if (decryptedDataObject.content) {
                    appendDecryptedField('Title', decryptedDataObject.name || '[N/A]');
                    appendDecryptedField('Password', decryptedDataObject.password);

                    const contentDiv = document.createElement('div');
                    contentDiv.style.marginTop = '15px';
                    
                    const contentLabel = document.createElement('span');
                    contentLabel.className = 'field-label';
                    contentLabel.style.width = 'auto';
                    contentLabel.style.display = 'block';
                    contentLabel.textContent = 'Content:';
                    contentDiv.appendChild(contentLabel);
                    
                    const preElement = document.createElement('pre');
                    preElement.style.marginTop = '5px';
                    preElement.style.background = '#fff';
                    preElement.style.border = '1px dashed #ccc';
                    preElement.style.padding = '10px';
                    preElement.style.fontSize = '0.9em';
                    preElement.textContent = decryptedDataObject.content;
                    contentDiv.appendChild(preElement);
                    
                    const copyBtnContainer = document.createElement('div');
                    copyBtnContainer.style.textAlign = 'right';
                    copyBtnContainer.appendChild(createCopyButton(decryptedDataObject.content));
                    contentDiv.appendChild(copyBtnContainer);
                    
                    contentBox.appendChild(contentDiv);
                } else {
                    contentBox.innerHTML = `
                        <p class="error-message">Unknown structure detected, displaying raw JSON:</p>
                        <pre>${JSON.stringify(decryptedDataObject, null, 2)}</pre>
                    `;
                }
                
                // Display Last Changed Timestamp
                const changedTimestamp = decryptedDataObject.last_changed;
                if (changedTimestamp) {
                     let displayValue = changedTimestamp;
                     try {
                        if (changedTimestamp.includes('T') && changedTimestamp.includes('Z')) {
                             displayValue = new Intl.DateTimeFormat(navigator.language, {
                                 year: 'numeric', month: 'short', day: 'numeric',
                                 hour: '2-digit', minute: '2-digit', second: '2-digit',
                                 timeZoneName: 'short'
                             }).format(new Date(changedTimestamp));
                             displayValue += ' (Client Local Time)';
                        }
                     } catch (e) {
                         // Fallback
                     }
                     appendDecryptedField('Last Changed', displayValue);
                } else {
                     appendDecryptedField('Last Changed', '[Unknown]');
                }

                if (decryptedDataObject.metadata) {
                    contentBox.innerHTML += `
                        <details style="margin-top: 15px;">
                            <summary style="font-size: 0.9em; font-weight: 500; color: #6c757d; cursor: pointer;">Metadata</summary>
                            <p style="font-size: 0.8em; margin: 5px 0 0 10px; color: #999;">
                                Saved: ${decryptedDataObject.metadata.saveTime}<br>
                                Browser: ${decryptedDataObject.metadata.browser}<br>
                                Platform: ${decryptedDataObject.metadata.platform}
                            </p>
                        </details>
                    `;
                }

                container.appendChild(contentBox);
                decryptionOutput.appendChild(container);
                
                setStatus(`Decryption successful for "${entryName}".`, false);
                
                // Show and assign the edit function on successful decryption
                editButton.style.display = 'inline-block';
                editButton.onclick = () => populateEntryForm(decryptedDataObject);

                // Show the delete button on successful decryption
                deleteButton.style.display = 'inline-block';

                // Start timer after successful decryption
                resetMasterPasswordTimer(); 
                 
             } catch (error) {
                 console.error("Decryption failed:", error);
                 let errorMessage = error.message;
                 if (errorMessage.includes("Authentication failed")) {
                    errorMessage = "Decryption failed! The **Entry Decryption Master Password** is incorrect or the data is corrupted.";
                 } else if (errorMessage.includes("HMAC tag missing")) {
                     errorMessage = "Decryption failed! This file is an older format and is missing the integrity tag. Please re-encrypt this entry or create a new one.";
                 } else if (errorMessage.includes("Failed to fetch file content")) {
                    errorMessage = `Failed to fetch file: Check your GitHub Token permissions or if the file exists.`;
                 }
                 decryptionOutput.innerHTML = `<p class="error-message" style="display:block; padding: 10px; border: 1px solid #f5c6cb; border-radius: 4px; background-color: #fff; font-weight: normal;">${errorMessage}</p>`;
                 setStatus(`Decryption failed for "${entryName}".`, true);
             }
        }
        // --- END DECRYPTION FUNCTION ---

        // --- COPY HELPER FUNCTIONS (UNCHANGED) ---
        
        async function copyStringValue(value, buttonElement) {
            try {
                await navigator.clipboard.writeText(value);
                
                const originalText = buttonElement.innerHTML;
                buttonElement.innerHTML = '‚úÖ Copied!';
                setTimeout(() => { buttonElement.innerHTML = originalText; }, 1500);

            } catch (err) {
                console.error('Failed to copy: ', err);
                alert('Could not copy to clipboard. Ensure your browser grants clipboard access.');
            }
        }

        function createCopyButton(value) {
            const button = document.createElement('button');
            button.className = 'copy-utility-button';
            button.innerHTML = 'üìã Copy';
            button.title = 'Copy value to clipboard';
            button.onclick = (e) => {
                e.stopPropagation(); 
                copyStringValue(value, button);
            };
            return button;
        }

        function copyToClipboard(inputId) { 
            const input = document.getElementById(inputId);
            input.select();
            input.setSelectionRange(0, 99999); 
            navigator.clipboard.writeText(input.value)
                .then(() => {
                    alert(`Copied ${input.tagName === 'TEXTAREA' ? 'Content' : inputId.replace('_', ' ')} to clipboard!`);
                })
                .catch(err => {
                    console.error('Failed to copy: ', err);
                    alert('Could not copy to clipboard. Please try manually.');
                });
        }

        // --- UI Initialization and Utility Functions (REST UNCHANGED) ---
        
        async function checkKeyStatusAndUpdateUI() {
            if (!config) return; 
            
            const keyStatusHint = document.getElementById('key_status_hint');
            const masterInput = document.getElementById('master_password');
            
            try {
                const keyData = await getMasterKeyData();
                if (keyData) {
                    // Key is set up
                    keyStatusHint.style.display = 'none';
                    masterInput.focus(); 
                } else {
                    // Key is NOT set up - show the helpful hint
                    keyStatusHint.style.display = 'block';
                    masterInput.focus();
                }
            } catch (error) {
                console.error("Failed to check key status:", error);
            }
        }

        function generatePassphrase() { 
            const numWords = Math.floor(Math.random() * 3) + 3; 
            let passphrase = [];
            for (let i = 0; i < numWords; i++) {
                const randomIndex = Math.floor(Math.random() * DIC.length);
                passphrase.push(DIC[randomIndex]);
            }
            const finalPassphrase = passphrase.join('-'); 
            document.getElementById("password").value = finalPassphrase;
            document.getElementById("confirm_password").value = finalPassphrase;
            checkPasswordStrength(finalPassphrase);
            copyToClipboard('password');
        }

        function switchMode(mode) { 
            const websiteFields = document.getElementById('website_fields');
            const websiteInputs = websiteFields.querySelectorAll('input');
            const textFields = document.getElementById('text_fields');
            const textInputs = textFields.querySelectorAll('input, textarea');
            const btnWebsite = document.getElementById('btn_website');
            const btnText = document.getElementById('btn_text');

            if (mode === 'website') {
                websiteFields.style.display = 'block';
                textFields.style.display = 'none';
                btnWebsite.classList.add('active');
                btnText.classList.remove('active');
                websiteInputs.forEach(input => input.disabled = false);
                textInputs.forEach(input => input.disabled = true);
            } else if (mode === 'text') {
                websiteFields.style.display = 'none';
                textFields.style.display = 'block';
                btnWebsite.classList.remove('active');
                btnText.classList.add('active');
                websiteInputs.forEach(input => input.disabled = true);
                textInputs.forEach(input => input.disabled = false);
            }
        }

        function togglePasswordVisibility(inputId) { 
            const input = document.getElementById(inputId);
            const button = input.parentElement.querySelector(`button[onclick*="${inputId}"]`);
            if (input.type === "password") {
                input.type = "text";
                button.innerHTML = '&#x1F576;';
                button.title = "Hide Password";
            } else {
                input.type = "password";
                button.innerHTML = '&#x1F441;';
                button.title = "Show Password";
            }
        }
        
        function generatePassword() { 
            const length = 12;
            const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=";
            let password = "";
            for (let i = 0; i < length; i++) {
                const randomIndex = Math.floor(Math.random() * charset.length);
                password += charset[randomIndex];
            }
            document.getElementById("password").value = password;
            document.getElementById("confirm_password").value = password;
            checkPasswordStrength(password);
            copyToClipboard('password');
        }

        function getStrengthMetrics(password) {
            let score = 0;
            if (password.length >= 8) score += 1;
            if (password.length >= 15) score += 1;
            if (/[a-z]/.test(password)) score += 1;
            if (/[A-Z]/.test(password)) score += 1;
            if (/\d/.test(password)) score += 1;
            if (/[^a-zA-Z0-9\s]/.test(password)) score += 1;
            
            if (password.length === 0) {
                return { percent: 0, color: '#eee', text: '' };
            } else if (score < 3) {
                return { percent: 30, color: 'weak', text: 'Weak' };
            } else if (score < 5) {
                return { percent: 60, color: 'medium', text: 'Medium' };
            } else {
                return { percent: 100, color: 'strong', text: 'Strong' };
            }
        }

        function checkPasswordStrength(p) { 
            const password = p || document.getElementById("password").value;
            const bar = document.getElementById("password_bar");
            const strengthDisplay = document.getElementById("strength_display");
            
            const metrics = getStrengthMetrics(password);
            
            bar.style.width = metrics.percent + '%';
            bar.className = metrics.color; // Use CSS classes for color
            strengthDisplay.textContent = metrics.text;
        }

        window.onload = async function() {
            await loadConfig();
            if (config) {
                switchMenu('entry'); 
                switchMode('website'); 
                checkPasswordStrength();
                await checkKeyStatusAndUpdateUI(); 
                
                // Event Listeners for Ephemeral Key Timeout
                const masterInput = document.getElementById('master_password');
                
                // 1. Start/Reset timer on input
                masterInput.addEventListener('input', resetMasterPasswordTimer);
                
                // 2. Global listeners to reset the timer on activity
                window.addEventListener('mousemove', resetMasterPasswordTimer);
                window.addEventListener('keydown', resetMasterPasswordTimer);

                // 3. Clear the master password when the window loses focus (tab switch/minimize)
                window.onblur = function() {
                    if (masterInput.value.length > 0) {
                        clearMasterPassword();
                    }
                };
            }
        };
    </script>
</body>
</html>