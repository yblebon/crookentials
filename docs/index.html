<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Encrypt CSV + GitHub (vault/main/uploads/credentials)</title>
  <style>
    body { font-family: system-ui, Arial; max-width: 900px; margin: 2rem; }
    label, button { display:block; margin: .5rem 0; }
    #status { margin-top: 1rem; color: #444; white-space: pre-wrap; }
    .grid { display:grid; grid-template-columns: 1fr 1fr 1fr; gap: .5rem; }
    fieldset { padding: .5rem; border: 1px solid #ddd; }
  </style>
</head>
<body>
  <h1>Encrypt CSV — create credentials or upload file — PBKDF2(SHA-256) + AES-GCM + GitHub</h1>

  <fieldset>
    <legend>Mode</legend>
    <label><input type="radio" name="mode" value="file" checked> File upload (choose a file to encrypt)</label>
    <label><input type="radio" name="mode" value="create"> Create CSV from credentials (enter login, password & website or upload CSV)</label>
  </fieldset>

  <div id="file-section">
    <label>Choose file:
      <input id="file" type="file" />
    </label>
  </div>

  <div id="create-section" style="display:none; border:1px solid #eee; padding:.5rem; margin-top:.5rem;">
    <div class="grid">
      <label>Login:
        <input id="cred-login" type="text" placeholder="user@example.com" />
      </label>
      <label>Password:
        <input id="cred-password" type="text" placeholder="secret" />
      </label>
      <label>Website:
        <input id="cred-website" type="text" placeholder="https://example.com" />
      </label>
    </div>
    <div style="margin-top:.5rem;">
      <label>Or upload a CSV containing headers "login", "password" and optionally "website" (case-insensitive). The first matching row will be used:
        <input id="cred-csv" type="file" accept=".csv,text/csv" />
      </label>
    </div>
    <div style="font-size:90%; color:#555; margin-top:.5rem;">
      Generated CSV will use header: <strong>login,password,website</strong>.
    </div>
  </div>

  <label>Password for encryption:
    <input id="password" type="password" />
  </label>

  <label>PBKDF2 iterations:
    <input id="iters" type="number" value="200000" min="1" />
  </label>

  <fieldset>
    <legend>Output destination</legend>
    <label><input type="radio" name="dest" value="download" checked> Download locally</label>
    <label><input type="radio" name="dest" value="github"> Upload to GitHub (vault/main/uploads/credentials)</label>
  </fieldset>

  <div id="github-fields" style="display:none; border:1px solid #ddd; padding:.5rem; margin-top:.5rem;">
    <div class="grid" style="grid-template-columns: 1fr 1fr;">
      <label>GitHub token (personal access token):
        <input id="gh-token" type="password" placeholder="ghp_xxx..." />
      </label>
      <label>Owner (user or org):
        <input id="gh-owner" type="text" placeholder="username or org" />
      </label>
    </div>
    <label>Optional filename suffix (e.g., .enc or timestamp will be appended):
      <input id="gh-suffix" type="text" placeholder=".enc" value=".enc" />
    </label>
    <label>Commit message:
      <input id="gh-message" type="text" placeholder="Add encrypted file" value="Add encrypted file via web UI" />
    </label>
    <div style="margin-top:.5rem; font-size:90%; color:#555;">
      Repo: <strong>vault</strong> — Branch: <strong>main</strong> — Path prefix: <strong>uploads/credentials</strong>
    </div>
  </div>

  <button id="encrypt">Encrypt & proceed</button>

  <div id="status"></div>

<script>
const BUF = (n) => new Uint8Array(n);
function randBytes(n){ const b = new Uint8Array(n); crypto.getRandomValues(b); return b; }

async function deriveKey(password, salt, iterations, length=32){
  const enc = new TextEncoder();
  const pwKey = await crypto.subtle.importKey("raw", enc.encode(password), {name:"PBKDF2"}, false, ["deriveBits"]);
  const derivedBits = await crypto.subtle.deriveBits(
    { name: "PBKDF2", salt: salt, iterations: iterations, hash: "SHA-256" },
    pwKey,
    length * 8
  );
  return crypto.subtle.importKey("raw", derivedBits, { name: "AES-GCM" }, false, ["encrypt","decrypt"]);
}
function concatUint8Arrays(arrays){
  const total = arrays.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let offset=0;
  for(const a of arrays){ out.set(a, offset); offset += a.length; }
  return out;
}
function toBase64(u8){
  let CHUNK = 0x8000;
  let index = 0;
  let res = '';
  while(index < u8.length){
    let slice = u8.subarray(index, Math.min(index + CHUNK, u8.length));
    res += String.fromCharCode.apply(null, slice);
    index += CHUNK;
  }
  return btoa(res);
}

function parseCSVFirstRowWithHeaders(csvText, headers){
  const lines = csvText.split(/\r?\n/).map(l=>l.trim()).filter(l=>l.length>0);
  if(lines.length === 0) return null;
  const headerLine = lines[0];
  const cols = headerLine.split(',').map(h=>h.trim().replace(/^"|"$/g,'').toLowerCase());
  const idx = {};
  for(let i=0;i<cols.length;i++) idx[cols[i]] = i;
  const needed = headers.map(h=>h.toLowerCase());
  // website is optional, include if present
  for(const h of ['login','password']) if(!(h in idx)) return null;
  const outRow = { login: '', password: '', website: '' };
  for(let r=1;r<lines.length;r++){
    const parts = lines[r].match(/(".*?"|[^",\s]+)(?=\s*,|\s*$)/g) || [];
    if(parts.length < Object.keys(idx).length) continue;
    outRow.login = parts[idx['login']].replace(/^"|"$/g,'') || '';
    outRow.password = parts[idx['password']].replace(/^"|"$/g,'') || '';
    outRow.website = (idx['website'] !== undefined) ? (parts[idx['website']].replace(/^"|"$/g,'') || '') : '';
    return outRow;
  }
  return null;
}

document.querySelectorAll('input[name="mode"]').forEach(r=>{
  r.addEventListener('change', ()=> {
    document.getElementById('file-section').style.display = (r.value === 'file' && r.checked) ? 'block' : 'none';
    document.getElementById('create-section').style.display = (r.value === 'create' && r.checked) ? 'block' : 'none';
  });
});
document.querySelectorAll('input[name="dest"]').forEach(r=>{
  r.addEventListener('change', ()=> {
    document.getElementById('github-fields').style.display = (r.value === 'github' && r.checked) ? 'block' : 'none';
  });
});

async function buildCredentialsCSVFromInputs(statusEl){
  const login = document.getElementById('cred-login').value.trim();
  const password = document.getElementById('cred-password').value;
  const website = document.getElementById('cred-website').value.trim();
  const fileInput = document.getElementById('cred-csv');
  if(login && password){
    const esc = (s)=>`"${String(s).replace(/"/g,'""')}"`;
    const csvText = `login,password,website\n${esc(login)},${esc(password)},${esc(website)}\n`;
    return { name: `credentials_${Date.now()}.csv`, data: new TextEncoder().encode(csvText) };
  }
  if(fileInput.files.length){
    statusEl.textContent = 'Reading uploaded CSV to extract first login/password/website...';
    const txt = await fileInput.files[0].text();
    const row = parseCSVFirstRowWithHeaders(txt, ['login','password','website']);
    if(!row) throw new Error('Uploaded CSV did not contain headers "login" and "password" or had no valid rows.');
    const esc = (s)=>`"${String(s||'').replace(/"/g,'""')}"`;
    const csvText = `login,password,website\n${esc(row.login)},${esc(row.password)},${esc(row.website||'')}\n`;
    return { name: fileInput.files[0].name, data: new TextEncoder().encode(csvText) };
  }
  throw new Error('Provide login and password (and optional website) or upload a CSV with headers "login" and "password".');
}

async function encryptBuffer(plainU8, password, iterations, statusEl){
  statusEl.textContent = 'Generating salt & nonce...';
  const salt = randBytes(16);
  const nonce = randBytes(12);

  statusEl.textContent = 'Deriving key (PBKDF2 SHA-256)...';
  const aesKey = await deriveKey(password, salt, iterations, 32);

  statusEl.textContent = 'Encrypting (AES-GCM)...';
  const alg = { name: "AES-GCM", iv: nonce, tagLength: 128 };
  const encrypted = await crypto.subtle.encrypt(alg, aesKey, plainU8);
  const encryptedU8 = new Uint8Array(encrypted);

  const outBuf = concatUint8Arrays([salt, nonce, encryptedU8]);
  return outBuf;
}

async function githubGetFileSha(owner, repo, path, branch, token){
  const url = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch)}`;
  const res = await fetch(url, { headers: { Authorization: `token ${token}`, Accept: 'application/vnd.github.v3+json' }});
  if(res.status === 200){
    const j = await res.json();
    return j.sha;
  }
  if(res.status === 404) return null;
  const txt = await res.text();
  throw new Error(`GitHub GET error: ${res.status} ${txt}`);
}

async function uploadToGitHub(owner, repo, path, branch, token, contentBase64, message, sha, statusEl){
  const url = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/contents/${encodeURIComponent(path)}`;
  const body = { message, content: contentBase64, branch };
  if(sha) body.sha = sha;
  statusEl.textContent = 'Uploading to GitHub...';
  const res = await fetch(url, {
    method: 'PUT',
    headers: { Authorization: `token ${token}`, Accept: 'application/vnd.github.v3+json', 'Content-Type':'application/json' },
    body: JSON.stringify(body)
  });
  if(!res.ok){
    const txt = await res.text();
    throw new Error(`GitHub upload failed: ${res.status} ${txt}`);
  }
  return res.json();
}

document.getElementById('encrypt').addEventListener('click', async ()=>{
  const status = document.getElementById('status');
  status.textContent = '';
  try{
    const mode = document.querySelector('input[name="mode"]:checked').value;
    const encPassword = document.getElementById('password').value || '';
    const iterations = parseInt(document.getElementById('iters').value) || 200000;
    if(!encPassword) { status.textContent = 'Enter encryption password.'; return; }

    let filename, plainU8;
    if(mode === 'file'){
      const fi = document.getElementById('file');
      if(!fi.files.length){ status.textContent = 'Select a file.'; return; }
      filename = fi.files[0].name;
      status.textContent = 'Reading file...';
      plainU8 = new Uint8Array(await fi.files[0].arrayBuffer());
    }else{
      const csv = await buildCredentialsCSVFromInputs(status);
      filename = csv.name;
      plainU8 = csv.data;
    }

    const outBuf = await encryptBuffer(plainU8, encPassword, iterations, status);

    const dest = document.querySelector('input[name="dest"]:checked').value;
    if(dest === 'download'){
      status.textContent = 'Preparing download...';
      const blob = new Blob([outBuf], {type: 'application/octet-stream'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename + '.enc';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      status.textContent = `Done. Download started (file: ${a.download}).\nFormat: salt(16)||nonce(12)||ciphertext||tag(16).\nPBKDF2 iterations: ${iterations}`;
      return;
    }

    // GitHub upload path (hardcoded repo/branch/path prefix)
    const token = document.getElementById('gh-token').value.trim();
    const owner = document.getElementById('gh-owner').value.trim();
    const suffix = document.getElementById('gh-suffix').value || '.enc';
    const message = document.getElementById('gh-message').value.trim() || `Add ${filename}${suffix}`;

    if(!token || !owner){
      status.textContent = 'Fill GitHub token and owner.';
      return;
    }

    const repo = 'vault';
    const branch = 'main';
    const pathPrefix = 'uploads/credentials';
    const safeFilename = filename.replace(/^.*[\\/]/,''); // strip dirs
    const fullPath = pathPrefix.replace(/\/$/,'') + '/' + (safeFilename + suffix).replace(/^\/+/,'');

    status.textContent = 'Preparing file for upload (base64)...';
    const contentBase64 = toBase64(outBuf);

    status.textContent = 'Checking existing file on GitHub (to get SHA if updating)...';
    let sha = null;
    try{
      sha = await githubGetFileSha(owner, repo, fullPath, branch, token);
    }catch(err){
      throw err;
    }

    const resp = await uploadToGitHub(owner, repo, fullPath, branch, token, contentBase64, message, sha, status);
    status.textContent = `Upload successful. File URL: ${resp.content.html_url || '(no html_url returned)'}\nRepo: ${owner}/vault\nPath: ${fullPath}\nBranch: main\nPBKDF2 iterations: ${iterations}\nFormat: salt(16)||nonce(12)||ciphertext||tag(16)`;
  }catch(err){
    status.textContent = 'Error: ' + (err.message || String(err));
    console.error(err);
  }
});
</script>
</body>
</html>
